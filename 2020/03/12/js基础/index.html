<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>
        Hexo
    </title>
    <link rel="shortcut icon" href="/images/favicon.ico">
        
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/css/meethigher-font.css">

            
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/css/animate.css">

                
<link rel="stylesheet" href="/css/index.css">

<meta name="generator" content="Hexo 4.2.0"></head>

    <body>
        <header class="header">
    <div class="header-menu"><span class="fa fa-bars"></span></div>
    <div class="header-search"><span class="fa fa-search"></span></div>
    <div class="header-title"><a href="/">Hexo | <span class="header-subtitle"></span></a></div>
    <ul class="header-navbar clearFix">
        
            <li><a href="/">主页</a></li>
        
            <li><a href="/tags">标签</a></li>
        
            <li><a href="/archives">归档</a></li>
        
    </ul>
</header>
            <main class="main">
                <div class="main-content meethigher-scroll">
    <article class="post">
        <div class="post-title">
            <h2 class="title">js基础</h2>
        </div>
        <div class="post-media2">
            <span class="post-time">2020-03-12</span>
            
        </div>
        <div class="post-content blog-markdown">
            <p><strong>JS概论</strong></p>
<p>HTML/CSS-标记语言</p>
<p>JS脚本语言-编程类语言</p>
<p><strong>浏览器分成两部分，渲染引擎和JS引擎</strong></p>
<p>渲染引擎:用来解析HTML与CSS，俗称内核,比如chrome的blink</p>
<p>JS引擎：JS解释器，用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的V8</p>
<p>浏览器本身并不会执行JS代码，而是通过内置JavaScript引擎来执行JS代码，JS引擎执行代码时逐行解释每一句源码（转换为机器语言二进制），然后由计算机去执行</p>
<p><strong>解释性语言：进行时立即解释执行的语言 如js</strong></p>
<p><strong>编译性语言：必须通过编译生成中间代码后才执行的语言 如java、c</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cfffb8145a3d84ffd90c259d05fae27c6%5C91c376eaf8dc4cf7ac0825ecdf328d19.jpg" alt="img"></p>
<p><strong>JS组成：ECMAscript（js语法）、DOM（页面文档对象模型）、BOM（浏览器对象模型）后两者即合称API</strong></p>
<p><strong>ECMAscript:规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准</strong></p>
<p><strong>JavaScript程序的执行</strong></p>
<p><strong>出现在<script>和</script>标记对之间的javascript语句按照它们在脚本中出现的顺序来执行。当一个文件有多个脚本的时候，脚本按照它们出现的顺序来执行（除非脚本带有defer属性）。<script>标记中的JS代码作为文档载入和解析过程的一部分来执行</strong></p>
<p><strong>JS词法结构</strong></p>
<p><strong>JS注释</strong></p>
<p><strong>单行注释：//</strong></p>
<p><strong>多行注释：/*......*/</strong></p>
<p>// 1.单行注释 ctrl+/ /<em>2.多行注释  2.多行注释  ctrl+shift+/</em>/ </p>
<p><strong>标识符、关键字、保留字、直接量</strong></p>
<p><strong>标识符：开发人员为变量、属性、函数、参数取的名字（标识符不能是关键字或保留字）</strong></p>
<p><strong>关键字：js本身已经使用了的字</strong></p>
<p><strong>保留字：为后面预留的关键字 如boolean byte char int等</strong></p>
<p><strong>字面量(直接量):程序中直接显示出来的数据值</strong></p>
<p>数字字面量：8，9，10</p>
<p>字符串字面量：“黑马程序员” “大前端”</p>
<p>布尔字面量：true false</p>
<p><strong>js命名规则</strong></p>
<p><strong>标识符命名规则</strong></p>
<p><strong>1.必须要有意义</strong></p>
<p><strong>2.变量一般用名词</strong></p>
<p><strong>3.函数一般用动词</strong></p>
<p><strong>4.不能与其他关键字同名</strong></p>
<p><strong>操作符规范</strong></p>
<p>操作符左右两侧各保留个空格</p>
<p><strong>单行注释//后加一个空格再写注释</strong></p>
<p><strong>末尾大括号要对齐其父元素</strong></p>
<p><strong>js嵌入HTML</strong></p>
<p><strong>行内式：放置在HTML事件处理程序中</strong></p>
<input type="botton" value="tangbohu" onclick="alert('秋香姐')"> 

<p>注意：</p>
<p><strong>1.可以将单行或少量JS代码写在HTML标签的事件属性中（以on开头的属性），如：onclick</strong></p>
<p><strong>2.注意单双引号的使用：在HTML中我们推荐使用双引号，JS中使用单引号</strong></p>
<p><strong>3.可读性差</strong></p>
<p><strong>4.引号易错，易混淆</strong></p>
<p><strong>5.特殊情况下使用</strong></p>
<p><strong>内联式（直接写在html文件中，一般写在body标签中所有元素后面）</strong></p>
<script>
    alert('sssssss');
</script>



<p><strong>外联式：放置在由<script>标签的src属性指定的外部js文件中</strong></p>
<script type="text/javascript" src="my.js">此处不可写代码</script>

<p><strong>注意：引用外部js文件的script标签中间不可以写代码</strong></p>
<p>执行顺序就是他们在文档中出现的顺序</p>
<p><strong>指定脚本语言</strong></p>
<meta http-equiv="Content-Script-Type" content="text/javascript">

<p><strong>一般浏览器会假设js为默认脚本化语言，如果没有指定默认语言，或者想覆盖默认语言，可以使用type属性</strong></p>
<script type="text/javascript">



**script标记的属性defer、async**

脚本的执行在默认情况下是同步和阻塞的。但是如果有了属性defer或者async，情况会发生变化。

**defer作用：浏览器解析遇到带有defer属性的script标记时，延迟该脚本的执行。文档的载入和解析完成再继续执行**

**async作用：浏览器可以尽快执行脚本，不用在下载脚本时阻塞文档解析。即一边下载js一边解析文档，js**

**如果两者同时都有，那么会遵从async而忽略defer** 



**JS输入输出语句**

**alert（msg）   浏览器弹出警示框** 

**console.log(msg)    浏览器控制台打印输出信息**  

**prompt(info)  浏览器弹出输入框，用户可以输入，输入的是字符串**

**confirm（msg） 浏览器弹出确认框，点击确认返回true，否则返回false**

<script type="text/javascript">
        // 这是一个输入框
        prompt('请输入您的年龄');
        // 弹出警示框 输出展示给用户的
        alert('输入结果是：');
        // console 控制台输出 便于测试
        console.log('我是程序猿');
          //弹出确认框
          var w = confirm("你确定吗?")；
</script>

<p>注意：confirm、prompt、alert都会产生阻塞，但他们弹出时，代码会停止运行。</p>
<p><strong>JS变量</strong></p>
<p><strong>声明和初始化</strong></p>
<p><strong>1.声明变量</strong></p>
<p>// 声明变量  var age; //声明一个名为age的变量 </p>
<p>var=variable</p>
<p><strong>2.赋值</strong></p>
<p>age = 10；  </p>
<p>=表示把右边的值赋予左边的值</p>
<p><strong>变量的初始化</strong></p>
<p>var age=10； </p>
<p><strong>变量语法扩展</strong></p>
<p>var myname='pink老师';         console.log(myname);         myname='pink';         console.log(myname); </p>
<p>变量值只取就近一个</p>
<p><strong>声明多个变量</strong></p>
<p> var age=18, address='火影村', gz=2000; </p>
<p><strong>声明变量的特殊情况</strong></p>
<p> // 1.只声明不赋值 结果为undefined var sex; console.log(sex); // 2.不声明不赋值 直接使用某个变量 结果报错 // console.log(tel); // 不声明直接赋值 结果正确 不推荐  qq =110; console.log(qq); </p>
<p><strong>变量命名规范</strong></p>
<p><strong>1.由字母数字下划线美元符号构成，不能有横杠！！！</strong></p>
<p><strong>2.区分大小写</strong></p>
<p><strong>3.不能数字开头</strong></p>
<p><strong>4.不能是关键字、保留字</strong></p>
<p><strong>5.变量名必须有意义</strong></p>
<p><strong>6.遵守驼峰命名法</strong></p>
<p><strong>7.对于内部使用的函数变量可以用下划线开头结尾的格式命名</strong>  </p>
<p><strong>作用域（变量起作用的范围，可以提高程序的可靠性，减少命名冲突）</strong></p>
<p><strong>作用域类型</strong></p>
<p>1.全局作用域：整个script标签内 或是一个单独的js文件</p>
<p>2.局部作用域：在函数内部，代码名字只在函数内部起效果和作用</p>
<p><strong>根据作用域的不同，变量可分为：1.全局变量 2.局部变量</strong></p>
<p>1.全局变量：在全局起作用的变量</p>
<p>2.局部变量：在局部作用域下的变量（函数内部的变量） 函数形参亦可以看做局部变量</p>
<p>从执行效率看</p>
<p>1.全局变量只有浏览器关闭时才会销毁，比较占内存资源</p>
<p>2.局部变量在程序执行完毕时即销毁</p>
<p><strong>现阶段js没有块级作用域（即花括号包含之内）：函数中声明的所有变量，无论是在那里声明在整个函数中都是有定义的，因为变量提升的原因</strong></p>
<p><strong>全局对象和调用对象</strong></p>
<p><strong>全局对象：当js解释器开始运行时，它首先要做的是在执行任何js代码前创建一个全局对象，而全局变量就是这个全局对象的属性。在客户端JS（嵌入网页的JS）中，这个全局对象就是Window对象</strong></p>
<p><strong>调用对象：每调用一次函数时，会在该函数作用域链前加一个调用对象。函数的参数和局部变量是作为调用对象的属性而存储的。用一个完全独立的对象来存储局部变量使JS可以防止局部变量覆盖同名的全局变量的值</strong></p>
<p><strong>作用域链（为一个对象列表或对象链。在一个**</strong>非嵌套函数中，作用域链由这个函数的调用对象和全局对象组成<strong>**）</strong></p>
<p>内部函数访问外部函数的变量，采取的是<strong>链式查找</strong>的方式根据就近原则来决定取那个值</p>
<script type="text/javascript">
    var num = 10;
    function fn() {
        var num = 20;
        function fun() {
            console.log(num);
        }
        fun();
    }
    fn();
</script>   结果是20



<p><strong>垃圾收集</strong></p>
<p>JavaScript每次创建字符串数组或对象时，解释器都必须f分配内存储存实体</p>
<p>与C、C++不同，js有<strong>垃圾收集</strong>的机制，解释器可以检测何时程序不再使用一个对象，<strong>当确定了对象是无用的时候，会自动释放其占用的内存</strong></p>
<p><strong>数据类型（占用内存大小不同）</strong></p>
<p><strong>js是一种弱类型或者说动态语言，不用提前声明变量的类型，在程序运行过程中，类型会自动被确定，js的变量数据类型只有被赋值后才被确定</strong></p>
<p><strong>相同的变量可用于不同的数据类型</strong></p>
<p><strong>简单数据类型：3种基本数据类型—数字型、字符串型和布尔型，两种小数据类型—null、undefined，还有ES6新增的symbol</strong></p>
<table>
<thead>
<tr>
<th>简单数据类型</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>Number</td>
<td>数字型，包含整型值和浮点型值，如21，0.21</td>
<td>0</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔型，如true、false</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>字符串类型，如“张三”</td>
<td>“”</td>
</tr>
<tr>
<td>Undefined</td>
<td>var a; 声明但没赋值 此时a=undefined</td>
<td>undefined</td>
</tr>
<tr>
<td>Null</td>
<td>var a=null; 声明了变量a为空值</td>
<td>null</td>
</tr>
</tbody></table>
<p><strong>复杂数据类型:对象(object)、数组(array)、函数(function)、日期(Date)、正则表达式(RegExp).本质上都是对象</strong></p>
<p><strong>数字型Number</strong></p>
<p>var num=10; var PI=3.14; var num1=010;    // 数字前面加0，代表八进制 console.log(num1);  // 数字前面加0x，代表16进制 var num2=0x9; var num4=0xa; // 最大值 console.log(Number.MAX_VALUE); // 最小值 console.log(Number.MIN_VALUE);  // 无穷大 console.log(Number.MAX_VALUE * 2);  /<em>输出infinity 无穷大</em>/ // 无穷小 console.log(-Number.MAX_VALUE * 2); /<em>输出-infinity 无穷小</em>/ // 非数值 NaN console.log('ab'-2); /<em>输出NaN</em>/ </p>
<p><strong>isNaN（）；  用来判断非数字 数字返回false 非数字返回true</strong></p>
<p>console.log(isNaN(12));  结果为false console.log(isNaN('dada'));  结果为true </p>
<p><strong>变量.toFixed（n）； 将变量保留n位小数</strong></p>
<p>var num =2.312313; console.log(num.toFixed(3)); // 2.312 </p>
<p><strong>字符串型（不是对象）</strong></p>
<p>语法:双引号或单引号（推荐）</p>
<p>嵌套：外双内单或者外单内双</p>
<p><strong>转义符（以\开头）</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Ce041c65ea275406e8949bbe4d31de77a%5C2635a5dd1182438b98d1fd0ff5f57ebf.jpg" alt="img"></p>
<p><strong>字符串的length属性（用于检测字符串长度）</strong></p>
<script type="text/javascript">
    // 检测获取字符串的长度
    var str = 'my name is andy';
    console.log(str.length);
</script>



<p><strong>字符串拼接</strong></p>
<p>多个字符串之间可以用+拼接，拼接方式为字符串+任何类型=拼接之后的新字符串</p>
<p>数值型和字符型之间也可以相加</p>
<p>口诀：数值相加，字符相连</p>
<script type="text/javascript">
    console.log('woshi'+'haha'); 结果是woshihaha
    console.log('wo'+12);    结果是wo12
    console.log('so'+true);        结果是sotrue
    console.log(12+12);    结果是24
    console.log('12'+12);    结果是1212
    var age=18;
    console.log('陈佳炜'+age+'岁'); 结果是陈佳炜18岁
    age=age+1;
    console.log('陈佳炜'+age+'岁'); 结果是陈佳炜19岁
</script>



<p><strong>布尔型</strong></p>
<p>布尔型有两个值：true和false，其中true表示真，false表示错</p>
<p>布尔型和数字型相加时,true为1，false为0</p>
<p><strong>Undefined</strong></p>
<p><strong>如果使用了一个**</strong>并未声明的变量<strong><strong>时，或者使用了</strong></strong>已经声明但还没有赋值的变量<strong><strong>时，又或者</strong></strong>使用了一个并不存在的对象属性<strong>**时，返回的就是undefined</strong></p>
<p>定义方式</p>
<p>var str; var str=undefined console.log(str+'aa'); 结果为undefinedaa console.log(str+1); undefined和数字相加，最后结果是NaN </p>
<p><strong>布尔环境中，它会转为false。数字环境中，会被转为NaN。字符串环境中，转为“undefined”</strong></p>
<p><strong>Null</strong></p>
<p><strong>即不是有效的对象、数组、数字、字符串和布尔值</strong></p>
<p>定义方式</p>
<p>var b=null; console.log(b); 结果为null console.log(b+'dadad'); 结果为nulldadad console.log(b+1);  结果为1 </p>
<p><strong>布尔环境中，它会转为false。数字环境中，会被转为0。字符串环境中，转为“null”</strong></p>
<p><strong>数据类型转换</strong></p>
<p><strong>转为字符型</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C02d6732e0bfa45c7b8f1f9367ea07aad%5C46e2a276128742e2a6366dbf2fdb0c38.jpg" alt="img"></p>
<p>用法</p>
<p>变量.toString() var num=10; var str=num.toString(); console.log(str); console.log(typeof str);  // console.log(typeof num);  // 利用 String()  // console.log(typeof String(num));  // 利用拼接字符串的方法  console.log(typeof (num+'')); </p>
<p><strong>toString（）可加参数，用来指定转换的基数，如为2，则转为二进制，如为8，则转为八进制，默认为10</strong></p>
<p>var num = 190; num = num.toString(2); console.log(num);// 1011110 </p>
<p><strong>前两种了解即可。推荐使用第三种，亦称为**</strong>隐式转换**</p>
<p><strong>转为数字型（重点）</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C750209ac5e81494b9539319ea9fc2c2a%5Ceb532fea5499406ca0f10e72bbc72dc8.jpg" alt="img"></p>
<p><strong>重点掌握parseInt() parseFloat()</strong></p>
<p>parseInt（）、parseFloat（）会从<strong>字符串开始处</strong>转换和返回<strong>任何的数字</strong>，自动忽略舍去<strong>非数字部分（前提是数字开头）</strong></p>
<p>console.log(parseInt("88 woshi"));// 88 console.log(parseInt("aa 88 woshi"));//NaN </p>
<p>parseInt可以解析<strong>“0x”或“0X"开头的数字</strong>，也可以接受另一个参数指定要解析的数字的基数<strong>(不能解析0开头的数字，除非显性地指定所使用的基数）</strong></p>
<p>console.log(parseInt("ff",16)); </p>
<p>parseInt(变量)  只能转为整数型 var age= prompt('请输入年龄'); console.log(parseInt(age)); console.log(parseInt('3.14'));  //3 取整 console.log(parseInt('120px'));  //会取消px单位 // parseFloat 可以吧字符型的转化为数字型 得到是小数 浮点数 console.log(parseFloat('3.14')); // Number() var str='123'; console.log(Number(str)); // 隐式转换  可以利用- * / 三种符号 console.log('12'-0); </p>
<p>注<strong>:Number()只对10十进制数字有限</strong></p>
<p><strong>转化为布尔型</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cbe1fee6ed519439eb34b329b97e9bee3%5Cc0325a464fa644f2aeae6040cf8431b7.jpg" alt="img"></p>
<p>代表空、否定的值都转化为false，如‘’，0，null，NaN，undefined。其他都转化为true</p>
<p>console.log(Boolean('')); console.log(Boolean(0)); console.log(Boolean(null)); console.log(Boolean(NaN)); console.log(Boolean(undefined)); console.log(Boolean(123)); </p>
<p><strong>运算符</strong></p>
<p>浮点数运算精确度远不如整数，不能直接拿浮点数比较是否相等</p>
<p><strong>表达式：由数字、运算符、变量组成的式子</strong></p>
<p>返回值：表达式返回的值</p>
<p><strong>递增递减运算符</strong></p>
<p>递增运算符（++） 递减运算符（--）</p>
<p>放在变量前面为前置递增 后面为后置递增</p>
<p>前置递增：先运算再取值</p>
<p>后置递增：先取值再运算</p>
<p>单独使用时两者结果相同</p>
<p><strong>比较运算符</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cb11bca1efc004a7a8a310a2372badd16%5C6564ed2d01f54ce7ab07d02dbad1824e.jpg" alt="img"></p>
<p><strong>= 赋值  == 判断（会转型）  ===全等（**</strong>不转型,即判断数据类型和值是否全部相等，对于对象数组函数来说则是判断是否引用同一个地址的对象数组函数<strong>**）</strong></p>
<p><strong>instanceof运算符（判断对象类型）</strong></p>
<p>instance：实例</p>
<p><strong>用于判断是否是某种特殊对象（数组、对象、日期）的实例</strong></p>
<p><strong>要求左边是对象，右边是一个类的名字</strong></p>
<p>var d = newDate(); d instanceof Object;//true </p>
<p><strong>注：instanceof是通过原型对象来判断一个实例属不属于某个构造函数创建的，而不是通过构造函数的名字</strong></p>
<p><strong>利用typeof获取变量数据类型（判断基本类型）</strong></p>
<p><strong>语法：typeof 变量</strong></p>
<p><strong>返回的是字符类型的小写的数据类型名称 'undefined' 'string' 'number' 'function''boolean',对于包装对象和DOM获得的元素返回的都是'object'对象，null和数组返回的是object</strong></p>
<p>var num=10; console.log(typeof num); var str='pink'; console.log(typeof str); var flag=true; console.log(typeof flag); var vari=undefined; console.log(typeof vari); var timer=null; console.log(typeof timer); var age=prompt('请输入年龄'); console.log(typeof age); </p>
<p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th>&&</th>
<th>与</th>
</tr>
</thead>
<tbody><tr>
<td>||</td>
<td>或</td>
</tr>
<tr>
<td>！</td>
<td>非</td>
</tr>
</tbody></table>
<p>如果是布尔值参与逻辑运算，则结果为布尔值</p>
<p>如果是具体数值或表达式参与运算，则发生逻辑中断，其中具体数值代表真，0 ‘’ null undefined NaN代表假</p>
<p>短路运算原理：当有多个表达式时,左边的表达式可以确定结果时，就不再运算右边的表达式的值</p>
<p><strong>表达式1 && 表达式2</strong></p>
<p><strong>如果第一个为真,不足以确定结果，那么就返回表达式2</strong></p>
<p><strong>如果第一个为假，足以确定结果，那么就返回表达式1</strong></p>
<p>console.log(0 && 456);   结果为0 console.log(123 && 456);  结果为456 </p>
<p><strong>表达式1 || 表达式2</strong></p>
<p><strong>如果第一个为真,足以确定结果，那么就返回表达式1</strong></p>
<p><strong>如果第一个为假，不足以确定结果，那么就返回表达式2</strong></p>
<p>console.log(123 || null);  结果为123 console.log(undefined || 456);   结果为456 var num=0; console.log(123 || console.log(num);   结果为0 </p>
<p><strong>赋值运算符</strong></p>
<p>=  赋值  后面赋值给前面</p>
<p>+=x   每次加x  num+=5；  num=num+5</p>
<p>-=x   每年减x  num-=5 ；    num=num-5</p>
<p>*=x 每次乘x</p>
<p>/=x 每次除x</p>
<p>%=x 每次除x取余</p>
<p><strong>运算符优先级</strong></p>
<p>1.小括号</p>
<p>2.一元运算符 ++ -- ！</p>
<p>3.算术运算符 先*/% 再 + -</p>
<p>4.关系运算符</p>
<p>5.相等运算符</p>
<p>6.逻辑运算符 先&& 后||</p>
<p>7.赋值运算符 =</p>
<p>8.逗号运算符， </p>
<p><strong>语句</strong></p>
<p><strong>三种结构</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cf4ef9b5f53a1444d9459dff8adb6fac7%5Ca3c68709572f43c19bf097e3c5b76ca6.jpg" alt="img"></p>
<p><strong>顺序结构：按照代码先后顺序，依次执行</strong></p>
<p><strong>分支结构：根据不同的条件，执行不同的路径代码（if、while）</strong></p>
<p><strong>if分支语句</strong></p>
<p>语法：if（条件表达式）{ 执行语句；}</p>
<p>如果条件表达式结果为真，则执行大括号里面的执行语句</p>
<p>如果条件表达式为假，则跳过if执行后面的代码</p>
<p>if() {} else {}</p>
<p>if（） {} else if {} else if {} else{} 先判断第一个 不符合则判断下一个</p>
<p><strong>三元表达式（由三元运算符？ ： 组成的表达式）</strong></p>
<p>语法结构</p>
<p>条件表达式？ 表达式1:表达式2  如果条件表达式结果为真，则返回表达式1的值，如果为假则返回表达式2</p>
<p><strong>switch语句</strong></p>
<p>switch（表达式） {</p>
<p>case value1： 执行语句1；break；</p>
<p>case value2： 执行语句2；break；</p>
<p>。。。</p>
<p>default：执行最后的语句；</p>
<p>}</p>
<p>匹配case的值，如果匹配，则运行该case里的值，如果都不匹配，则执行default里的值</p>
<p><strong>表达式里的值和case里的值相等是用全等===判定的，即必须是值和数据类型完全一致才可以</strong></p>
<p><strong>必须要有break，否则会执行下一个case</strong></p>
<p><strong>if else if 和switch的区别</strong></p>
<p><strong>1.前者一般用判断范围 后者一般用于确定值</strong></p>
<p><strong>2.前者需要判断多次，后者进行判断后直接执行到程序的条件语句，效率较高</strong></p>
<p><strong>3.分支较少时前者效率高</strong></p>
<p><strong>4.分支多时后者效率高且结构更清晰</strong></p>
<p><strong>循环结构（可重复执行一些代码）</strong></p>
<p><strong>for循环结构</strong></p>
<p>for（初始化变量；条件表达式；操作表达式) { 循环体；}</p>
<p>for()</p>
<p>for() {}</p>
<p>外层循环一次，里面的循环执行全部</p>
<p><strong>断点调试</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C2843de02167643a78053a781447b375a%5Cb34266e0c9ab40d79eb72e08234fd5d9.jpg" alt="img"></p>
<p><strong>while循环结构</strong></p>
<p>while（）{}</p>
<p>记得加入计数器，防止死循环</p>
<p><strong>do{} while（）循环</strong></p>
<p>先执行一次语句，再判断，若正确，则继续执行，否则退出</p>
<p>即循环体至少执行一次</p>
<p>总结：一般若与数字相关，常用for。while和dowhile可以执行更加复杂的循环。while先判断再执行，dowhile先执行再判断</p>
<p><strong>跳转语句</strong></p>
<p><strong>continue</strong></p>
<p>遇到continue就停止本次循环，直接跳到i++，不再执行循环体内continue后面语句</p>
<p>for (var i =1;i<=5;i++) {     if (i==3) {         continue;     }     console.log('我正在吃第'+i+'个包子'); } </p>
<p>结果</p>
<p>我正在吃第1个包子</p>
<p>我正在吃第2个包子</p>
<p>我正在吃第4个包子</p>
<p>我正在吃第5个包子</p>
<p><strong>break</strong></p>
<p>遇到break直接跳出此循环所属的for语句的所有循环</p>
<p>for(var i=1;i<=5;i++) {     if(i==3) {         break;     }     console.log('我正在吃第'+i+'个包子') } </p>
<p>结果</p>
<p>我正在吃第1个包子</p>
<p>我正在吃第2个包子</p>
<p><strong>throw</strong></p>
<p>用于抛出异常，用信号通知发生了错误或者异常状况</p>
<p>异常：发生了某种异常情况或错误时产生的一个信号。</p>
<p>语法格式：</p>
<p>throw expression；</p>
<p>expression可以使任意类型，一般为Error对象</p>
<p>function twoArg(o,t) {     if(arguments.length !== 2)          throw new Error('必须是两个参数'); } twoArg(1); </p>
<p>注意:当抛出异常时，JS解释器会停止当前正在执行的逻辑，跳转到最近的异常处理程序（即后面try/catch/finally中catch语句编写的程序）</p>
<p><strong>try/catch/finally</strong></p>
<p>try用于检查抛出异常</p>
<p>catch用于抓住异常，其参数便是try抛出的值</p>
<p>finally内的代码无论如何总会执行</p>
<p>try {             var n = prompt('enter a number');             // var t = prompt('enter a number');             if(n == 1) {                 throw 'wocao';             }         }         catch(e) {             alert(e);//wocao         } </p>
<p>注意：</p>
<p>1.try后面至少要跟随一个catch或者finally</p>
<p>2.catch的参数有局部作用域，只在catch语句中有效</p>
<p>3.如果没有catch从句，执行finally后会向上传播异常，直到找到能处理这个异常的catch从句</p>
<p><strong>数组（一组数据的集合）</strong></p>
<p><strong>创建方式：</strong></p>
<p><strong>1.利用new关键字创建数组</strong></p>
<p>var arr = new Array(); </p>
<p><strong>2.利用数组字面量创建数组</strong></p>
<p>var arr = ['a','b','c','d','e']; var arr = [1，2，‘dada'，true]; var arr=[]; </p>
<p>注意</p>
<p><strong>1.数组里面可以放任何数据类型</strong></p>
<p><strong>2.数组里面的数据称为数组元素</strong></p>
<p><strong>数组的索引</strong></p>
<p><strong>索引：用来访问数组元素的序号（**</strong>从0开始，最大为2^32 - 1<strong>**）</strong></p>
<p>数组的长度是元素个数，不要跟索引号混淆</p>
<p><strong>数组的遍历</strong></p>
<p><strong>遍历：就是把数组中的所有元素从头到尾访问一次；</strong></p>
<p>数组名.length:动态监测数组元素的个数，一般循环遍历时长度都用这个来表示</p>
<p>for(i=0;i<date.length;i++) { alert(date[i]); } </p>
<p><strong>数组元素增加</strong></p>
<p><strong>1.通过修改length新增数组元素</strong></p>
<p>先修改数组长度，再对新增元素赋值</p>
<p>若修改后的长度<原先的长度，则原数组会被截取。若修改后的长度>原先的长度，则原数组会添加多余个数的undefined</p>
<p> arr.length=5; arr[3]=4; arr[4]=5; </p>
<p><strong>2.通过修改数组索引的方式增加数组元素</strong></p>
<p>直接对未赋值的数组元素赋值，若赋值的索引号已被占用，则会被替换为新的元素值</p>
<p>var arr = [1, 2, 3]; arr[3]=4; </p>
<p><strong>注意：不要对数组名直接赋值，否则会清除所有数组元素</strong></p>
<p><strong>函数（封装了一段可被重复调用执行的代码块，通过函数可以实现大量代码的重复使用)</strong></p>
<p><strong>函数使用步骤：1.声明函数 2.调用函数</strong></p>
<p><strong>1.声明函数</strong></p>
<p><strong>声明方式1：</strong></p>
<p><strong>function 函数名（参数1，参数2，...）{ 函数体；}</strong></p>
<p><strong>注意：</strong></p>
<p><strong>1.function为声明函数的关键字，全部小写</strong></p>
<p><strong>2.函数名一般为动词，代表此函数要做什么</strong></p>
<p><strong>3.函数声明后被调用才能执行，不调用不执行</strong></p>
<p><strong>4.函数声明一般出现在js代码的顶层，也可以嵌套在其他函数中，但是只能嵌套在那些函数顶层中，不能出现在if，while或其他语句中</strong></p>
<p><strong>5.使用可选参数设计函数时，应该确保把可选的参数放参数列表的末尾</strong></p>
<p>function sayHi() {     alert('hi'); }     </p>
<p><strong>声明方式2：</strong></p>
<p><strong>var 变量名=function（参数1，参数2，...）{}； （匿名函数）</strong></p>
<p> var fun = function() {      console.log('我是傻逼');  } </p>
<p><strong>2.函数调用</strong></p>
<p><strong>函数名()；</strong></p>
<p>sayHi（）； </p>
<p>或者</p>
<p><strong>变量名（）; 针对第二种声明方式</strong></p>
<p>fun(); </p>
<p>注意：</p>
<p>调用函数时一定记得写小括号</p>
<p><strong>函数的参数：形参 实参</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Ce42fdae07684433f888f863dcdc1f29a%5C2859bb1fd22540a9a9a09ae212cc4a4a.jpg" alt="img"></p>
<p>多个参数之间逗号隔开</p>
<p><strong>如果实参个数多于形参个数，会取到形参的个数</strong></p>
<p><strong>如果实参个数小于形参的个数，没有赋值的形参则为undefined，结果为NaN</strong></p>
<p><strong>调用数组时直接写数组名字或者整个数组元素即可</strong></p>
<p><strong>函数返回值</strong></p>
<p>函数只是实现某种功能，最终结果需要return返回数值，return只能返回一个值</p>
<p>函数如果没有return，返回的是undefined</p>
<p><strong>return也有终止函数的功能</strong></p>
<p>可以利用数组实现返回多个值</p>
<p>function getResult(num1,num2) {     return [num1+num2, num1 - num2,num1 * num2, num1 / num2]; } var re= getResult(1,2); console.log(re); </p>
<p><strong>arguments的使用（存储函数传递的所有实参）</strong></p>
<p><strong>arguments是Arguments对象的实例，是当前函数的一个内置对象，所有函数都内置了一个arguments对象，**</strong>arguments只能在函数中调用，<strong><strong>可以按照数目获取函数的</strong></strong>实参<strong><strong>的参数值（</strong></strong>调用函数时写的参数而不是定义函数时写的形参<strong>**）</strong></p>
<p>当不确定有多少个参数传递的时候，可以用arguments来获取。</p>
<p>function fn() {     console.log(arguments); } fn(1,2,3); </p>
<p>arguments是一个伪数组，可以进行遍历，特点如下：</p>
<p><strong>1.具有length属性</strong></p>
<p><strong>2.按索引方式储存数据</strong></p>
<p><strong>3.不具有数组的push、pop等方法</strong></p>
<p><strong>arguments的属性</strong></p>
<p><strong>arguments.callee:返回arguments所在的函数</strong></p>
<p>function whoIsCalling() {     console.log(arguments.callee); } whoIsCalling();//返回whoIsCalling函数的代码 </p>
<p>该属性可用来实现回调</p>
<p><strong>在JS中，代码可以对函数进行操作。JS中的函数是真正的数据，可以被存储在变量中、数组和对象中，可以作为参数传递给其他函数</strong></p>
<p><strong>函数的属性方法</strong></p>
<p><strong>函数.length</strong></p>
<p><strong>返回函数**</strong>定义时<strong>**形参的个数</strong></p>
<p>function f(x,y) {     console.log(f.length);//2     console.log(arguments.length);//3 } f(1,2,3)； </p>
<p><strong>JS的预解析（小难点，看案例）</strong> </p>
<p><strong>js引擎运行分两步：</strong></p>
<p><strong>1.预解析：js引擎会把js里面所有的var 和 function提升到**</strong>当前作用域最前面**</p>
<p><strong>2.代码执行：按书写顺序依次执行代码</strong></p>
<p><strong>预解析分为：</strong></p>
<p><strong>1.变量预解析（变量提升）：把var提升到当前作用域的最前面，但不赋值</strong></p>
<p>function fun() {     console.log(num); } fun(); var num=10; 等价于 var num; function fun() {     console.log(num); } fun(); num=10;  fn(); var fn=function() {     console.log(11); } 等价于 var fn; fn(); fn=function() {     console.log(11); } </p>
<p><strong>2.函数预解析（函数提升）：把所有函数声明提升到当前作用域最前面，但不调用函数</strong></p>
<p>con(); function con() {     console.log(11); } 等价于 function con() { console.log(11); } con(); </p>
<p><strong>注意：var a=b=c=9； 预解析后等于var a；a=9；b=9;c=9; b和c变成全局变量</strong></p>
<p><strong>JS的对象</strong></p>
<p><strong>对象：**</strong>一组无序的相关属性和方法的集合，所有的事物 都是对象，<strong>**除了字符串、数字、true、false、null和undefined其他都是对象（事实上字符串数字布尔值可以被包装为包装对象）</strong></p>
<p><strong>对象由属性和方法构成</strong></p>
<p><strong>属性：事物的特征，在对象中用属性来表示（常用名词），属性值可以是任意的js表达式，等同于变量。</strong></p>
<p><strong>属性两种类型：</strong></p>
<p><strong>自有属性：直接在对象中定义的属性</strong></p>
<p><strong>继承属性：通过原型对象继承的属性</strong></p>
<p><strong>属性的三个特性：</strong></p>
<p><strong>值（value）：属性的值</strong></p>
<p><strong>可写（writable）：表明是否可以设置该属性的值</strong></p>
<p><strong>可枚举（enumerable）：表示是否可以通过for/in循环返回该属性</strong></p>
<p><strong>可配置（configurable）：表明是否可以删除或者修改该属性</strong></p>
<p><strong>方法：事物的行为，在对象中用方法来表示（常用动词），即存储在对象中的函数</strong></p>
<p><strong>对象有三种：1.自定义对象 2.内置对象 3.宿主对象 （前两者属于ECMAscript，后者属于客户端JavaScript）</strong></p>
<p><strong>创建对象</strong></p>
<p><strong>1.用字面量创建对象</strong></p>
<p><strong>var 对象名 = { 属性名： ‘属性值’，属性名： ‘属性值’，。。。}</strong></p>
<p>var obj = {     uname: '张三疯',     age: 18,     sex: '男',     sayHi: function() {         console.log('Hi');     } } </p>
<p><strong>调用对象</strong></p>
<p><strong>1.对象名.属性名</strong> </p>
<p><strong>2.对象名['属性名']（即作为关联数组的对象，允许动态地将任意数值和任意字符串关联在一起）</strong></p>
<p> console.log(obj.uname);  // (2) 第二种方法 对象名['属性名']  console.log(obj['age']); </p>
<p> <strong>变量、属性、函数、方法的区别</strong></p>
<p><strong>1.变量和属性都是用来存储数据，但变量需要声明属性不需要，变量可以直接写变量名调用，属性必须对象名.属性名调用，变量和属性基本等同</strong></p>
<p><strong>2.函数和方法都是实现某种功能。函数是单独声明且调用时是写函数名（）。方法在对象里声明且调用为 对象.方法（），对象中的函数即为方法</strong></p>
<p><strong>2.用new Object 创建对象</strong></p>
<p><strong>利用等号对属性进行赋值</strong></p>
<p>var obj = new Object(); obj.uname = '张三疯'; obj.age  = 18; obj.sex = '男'; obj.sayHi = function() {     console.log('Hi'); } </p>
<p><strong>调用对象</strong></p>
<p>console.log(obj.uname); console.log(obj.sex); obj.sayHi();     </p>
<p><strong>3.利用构造函数构造多个对象</strong></p>
<p><strong>构造函数：就是把对象里面一些相同的属性和方法抽出封装起来的函数，即构造对象的函数</strong></p>
<p>function 构造函数名(形参) {     this.属性 = 值;     this.方法 = function() {} } </p>
<p><strong>var 对象名 = new 构造函数名（实参）；</strong></p>
<p>function Star(uname,age,sex) {             this.name = uname;             this.age = age;             this.sex = sex;         }      var ldh = new Star('ldh',18,'male');  </p>
<p>注意点以及构造函数执行过程：</p>
<p><strong>1.构造函数名字首字母一般大写</strong></p>
<p><strong>2.构造函数不需要return</strong></p>
<p><strong>3.调用构造函数 必须使用new new构造函数在内存中创建了一个空的对象</strong></p>
<p><strong>4.必须使用this，this指向new创建的空对象</strong></p>
<p><strong>5.执行构造函数的代码后，就会给这个空对象添加属性和方法</strong></p>
<p><strong>6.new会返回创建后的对象</strong></p>
<p><strong>遍历对象</strong></p>
<p><strong>语法： for（变量 in 对象） {}</strong></p>
<p>for(var k in obj) {     console.log(k); // 遍历输出属性名     console.log(obj[k]); //遍历输出属性值 } </p>
<p>注意:</p>
<p>1.k可以改为任意变量名，一般用k</p>
<p>2.k为数组</p>
<p><strong>3.也可以用于数组！！！</strong></p>
<p>4.该方法会<strong>枚举所有可枚举的属性，包括自有属性和继承属性</strong>（除非利用Object.defineProperty（）人为设定为不可枚举）</p>
<p><strong>5.许多预定义内部属性和方法，包括所有的内部方法都是不可枚举的</strong></p>
<p><strong>删除属性</strong></p>
<p><strong>语法：delete 属性</strong></p>
<p>删除运算数指定的<strong>对象的属性、数组元素或变量</strong>（严格模式不可删除）。返回布尔值</p>
<p>内部核心属性、客户端属性、用var语句声明的用户定义变量都不能删除</p>
<p>var obj = {     num:10,     age:20 } delete obj.num; console.log(obj);// num消失 </p>
<p><strong>注意：</strong></p>
<p>delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性</p>
<p><strong>检查属性的存在性</strong></p>
<p>1.检测对象或数组中是否有某个属性，返回布尔值</p>
<p><strong>语法：属性名 in 对象或数组</strong></p>
<p>var obj = {     num:10,     age:20 } console.log("num" in obj);//true </p>
<p><strong>注意：**</strong>该方法可以检测所有的属性方法，包括自定义类内置的和原型链上的以及原始类的属性方法**</p>
<p>2.只能检测对象的自有属性</p>
<p><strong>语法：对象.hasOwnProperty(属性名） 返回布尔值</strong></p>
<p>function Star() {         this.name = 1     }     Star.prototype.age =12;     Object.prototype.male = 'man';     var ldh = new Star();      console.log(ldh.hasOwnProperty('name'));//true     console.log(ldh.hasOwnProperty('male'));//false </p>
<p><strong>确定对象类型</strong></p>
<p><strong>1.typeof：用于区分number、string、boolean、undefined、function、symbol这些基本类型</strong></p>
<p><strong>2.instanceof：一旦确定了一个值不是基本类型或函数，就可以用instanceof来确定是哪种内建对象的实例,对于基本类型包装对象无效</strong></p>
<p><strong>3.Object.toString（）：返回的是[object class]，class是对象的内部类型，通常与该对象的构造函数名字对应。如Array,Function,Date,Math</strong></p>
<p><strong>4.constructor:返回原型对象所属的类，返回的是整个构造函数</strong></p>
<p><strong>序列化对象（将对象的状态转为字符串或将字符串还原为对象）</strong></p>
<p><strong>利用JSON.stringify（）和JSON.parse()来序列化和还原对象</strong></p>
<p><strong>JSON（JavaScript Object Notation）:JavaScript对象表示法</strong></p>
<p><strong>内置对象</strong> </p>
<p>常用 Math Date Array String等</p>
<p><strong>1.数学对象</strong></p>
<p>不是构造函数，无需用new调用。而是可以直接调用其类属性及类方法</p>
<p><strong>调用属性 如 输出pi值 Math.PI</strong></p>
<p>console.log(Math.PI); // 3.14.... </p>
<p><strong>调用方法 如 取最大值 Math.max</strong></p>
<p>console.log(Math.max(1,2,3)); // 3 </p>
<p>如果有一个或一个以上的值为非整数型，则返回NaN</p>
<p>如果没有赋值，则返回-Infinity</p>
<p><strong>求开根号 Math.sqrt(x)  返回x的开根号值</strong></p>
<p>var x = Math.sqrt(81); console.log(x); </p>
<p><strong>求绝对值 Math.abs</strong>  </p>
<p>console.log(Math.abs(1)); //1 console.log(Math.abs(-1)); // 1 console.log(Math.abs('-1'));  // 1 有隐式转换 可以直接字符串转为数字型 console.log(Math.abs('哈哈'); // NaN </p>
<p><strong>三个取整方法</strong></p>
<p><strong>1.Math.floor（） 向下取整，往最小了取值,不会四舍五入</strong></p>
<p>console.log(Math.floor(1.1)); // 1 console.log(Math.floor(1.9)); // 1 </p>
<p><strong>2.Math.ceil（）  往上取整，往最大了取，不会四舍五入</strong></p>
<p>console.log(Math.ceil(1.9)); // 2 console.log(Math.ceil(1.1)); // 2 </p>
<p><strong>3.Math.round() 四舍五入取整**</strong>（其他都是四舍五入，只有5是往大了取）**</p>
<p>console.log(Math.round(1.1)); // 1 console.log(Math.round(1.9)); // 2 console.log(Math.round(-1.5)); // -1 </p>
<p><strong>随机数</strong></p>
<p><strong>Math.random() 返回一个随机的0到1之间的小数（不包含0和1）且不跟参数</strong></p>
<p>得到两个整数之间的随机整数：</p>
<p>function getRandom(min,max) {     console.log(Math.floor(Math.random()*(max-min+1)+min));   } </p>
<p><strong>2.日期对象</strong></p>
<p><strong>Date() 日期对象 是一个构造函数 必须使用new来调用创建自己的日期对象</strong></p>
<p>使用方法</p>
<p>var date = new Date(); console.log(date); </p>
<p>参数写法</p>
<p><strong>无参数则返回当前系统时间</strong></p>
<p>数字型：2019，10，01    字符型：’2019-10-1 8：8：8‘</p>
<p>var date1 = new Date(2019,10,1); or var date2 = new Date('2019-10-1 8:8:8'); </p>
<p>具体方法</p>
<p><strong>返回当前年份</strong></p>
<p><strong>对象名.getFullYear()</strong> </p>
<p><strong>返回当前月份</strong></p>
<p><strong>对象名.getMonth()+1</strong></p>
<p><strong>注意：是从0开始到11 所以应该+1 否则得到的月份少一个月</strong></p>
<p><strong>返回当前号数</strong></p>
<p><strong>对象名.getDate()</strong> </p>
<p><strong>返回周几</strong></p>
<p><strong>对象名.getDay()</strong> </p>
<p><strong>注意：是从0（即星期日）开始到6（星期六）</strong></p>
<p><strong>返回小时</strong></p>
<p><strong>对象名.getHours();</strong></p>
<p><strong>返回分钟</strong></p>
<p><strong>对象名.getMinutes()</strong></p>
<p><strong>返回秒钟</strong></p>
<p><strong>对象名.getSeconds()</strong></p>
<p><strong>返回自1970年来的总毫秒数</strong></p>
<p><strong>1.对象名.getvalueOf() 或者 对象名.getTime()</strong></p>
<p><strong>2.var 对象名 = +new Date();</strong></p>
<p><strong>3.console.log(Date.now())   低版本浏览器不支持</strong></p>
<p><strong>3.数组对象</strong></p>
<p>创建方式</p>
<p><strong>1.利用字面量</strong></p>
<p>var arr = [1,2,3]; console.log(arr[0]); </p>
<p><strong>2.利用new Array()</strong></p>
<p>var arr1 = new Array(); //空数组 var arr2 = new Array(2); //长度为2的空数组 var arr3 = new Array(2,3);// 内容为2和3的数组 </p>
<p><strong>检测变量是否为数组的方法</strong></p>
<p><strong>1.利用 instanceof</strong></p>
<p><strong>变量名 instanceof Array</strong> </p>
<p>返回的是布尔值</p>
<p>var arr = []; var obj = {}; console.log(arr instanceof Array); // 返回true console.log(arr instanceof Array); // 返回false </p>
<p>注：亦可用来判断是否为对象类型 ：变量名 instanceof Object</p>
<p><strong>2.利用Array内置对象的行为</strong></p>
<p><strong>Array.isArray（变量）</strong></p>
<p>返回的也是布尔值</p>
<p>Array.isArray([1,2,3]); // TRUE Array.isArray(1,2,3); // FALSE </p>
<p><strong>给数组添加元素的方法</strong></p>
<p><strong>1.末尾添加</strong></p>
<p>数组名.push（元素1，元素2，...）； </p>
<p>var arr = [1,2,3]; arr.push(1,'dada'); // 返回结果是数组长度 </p>
<p><strong>2.头部添加</strong></p>
<p>数组名.unshift（元素1，元素2，...）;</p>
<p>var arr = [1,2,3]; arr.unshift('red','purple');  // 返回结果是数组长度 </p>
<p><strong>3.尾部删除</strong></p>
<p>数组名.pop（）</p>
<p>arr.pop(); //pop没有参数 返回删除的元素 一次只能删除一个元素 </p>
<p><strong>4.头部删除</strong></p>
<p>数组名.shift()</p>
<p>arr.shift() //没有参数 返回删除的元素 一次只能删除一个 </p>
<p>总结</p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C626a3cafae634dc899997633d8cc7dbd%5Cd0925c276df34b83870456b2f29fc12e.jpg" alt="img"></p>
<p><strong>数组排序的方法</strong></p>
<p><strong>1.数组翻转</strong></p>
<p><strong>数组名.reverse（）；</strong></p>
<p>var arr = [1,2,3]; arr.reverse(); console.log(arr); </p>
<p><strong>2.数组排序</strong></p>
<p><strong>数组名.sort（）； 只对一位数起效，多位数会出错</strong></p>
<p><strong>数组名.sort(function(a,b) { a - b})  升序排序</strong></p>
<p><strong>数组名.sort(function(a,b) { b - a})  降序排序</strong></p>
<p>var arr1 = [3,4,8,12]; arr1.sort(function(a,b) {     // return a - b;  升序排列     return b - a; }); </p>
<p><strong>获取数组元素索引方式</strong></p>
<p><strong>1.变量名.indexOf(元素值);</strong></p>
<p>var arr = ['red','green','pink','blue'] console.log(arr.indexOf('blue')); </p>
<p>注：返回第一个满足条件的索引号 </p>
<p><strong>如果该数组里找不到元素，则返回-1</strong></p>
<p><strong>2.变量名.lastIndexOf（元素值）；</strong></p>
<p>注：从末尾开始找 返回正序的索引号</p>
<p>console.log(arr.lastIndexOf('blue')) </p>
<p>注：只能用于数组，不能用于节点</p>
<p><strong>数组转为字符串</strong></p>
<p><strong>1.变量名.toString（）；</strong></p>
<p>var arr = [1,2,3]; console.log(arr.toString()); </p>
<p><strong>2.变量名.join();</strong></p>
<p>把数组所有元素转换成字符串，再把它们连接起来。可以指定一个可选的字符串来分隔结果字符串中的元素。默认为逗号分隔</p>
<p>var arr1 = ['green','blue','pink']; console.log(arr1.join());//green,blue,pink console.log(arr1.join(''));//greenbluepink </p>
<p><strong>数组的截取删除连接</strong></p>
<p><strong>数组链接</strong></p>
<p>数组名1.concat（数组名2）；</p>
<p>数组名1.concat（元素值,元素值,...）；</p>
<p>var num1 = [1,2,3]; var num2 = ['a','b','c']; console.log(num1.concat(num2)); console.log(num1.concat(num2,1,[2,3])); </p>
<p><strong>数组删除插入（改变原数组,返回被删除的值）</strong></p>
<p><strong>数组名.splice(起始位置，删除个数，添加元素）</strong></p>
<p>var num3 = ['ha','xi','hei','he']; var num4 = num3.splice(1,0,'en'); // 在第1位后插入'en' var num5 = num3.splice(1,1); //第1位开始删除一位  console.log(num5); // 'xi' var num6 = num3.splice(2,1,'en','o'); console.log(num3);// 'ha' 'xi' 'en' 'o' 'he' </p>
<p><strong>数组截取(不会改变原数组，只是截取出来作为新数组）</strong></p>
<p><strong>数组名.slice(开始位置（包含），结束位置（不包含））；</strong></p>
<p>var num7 = [1,2,3,4,5,6]; console.log(num7.slice(2)); // 3,4,5,6 console.log(num7.slice(1,3));// 2,3 // num7依旧为1，2，3，4，5，6 </p>
<p><strong>4.字符串对象</strong></p>
<p><strong>基本包装类型：js不仅支持数字字符串和布尔值这些数据类型，还支持Number、String、Boolean类，这些类是其对应基本数据类型的包装。不仅具有和基本类型一样的值，还定义了用来运算数据的属性和方法</strong></p>
<p>过程：</p>
<p>（1）字符串值内部创建一个String包装对象</p>
<p>var temp = new String(字符串值)</p>
<p>(2)代替原始的字符串值</p>
<p>变量名 = temp；</p>
<p>（3）销毁temp</p>
<p>temp=null;</p>
<p><strong>字符串不可变性：字符串赋值后重新赋值需要重新创建内存空间，原先的内存及其值不变。所以不要大量拼接字符串，即字符串的值无法修改</strong></p>
<p><strong>字符串所有方法，都不会修改字符串本身内容，而是创建新的字符串</strong></p>
<p><strong>实例方法</strong></p>
<p><strong>根据字符串返回索引值</strong></p>
<p><strong>字符串名.indexOf（具体某个字符串，开始位置（默认无））;</strong></p>
<p>var str ='改革春风吹满地,春天来了'; console.log(str.indexOf('春')); // 返回2 console.log(str.indexOf('春',3)); // 返回8 </p>
<p><strong>根据索引值返回字符串</strong></p>
<p><strong>1.字符串变量名.charAt(索引值）</strong></p>
<p>var str='1234'; var a = str.charAt(1); </p>
<p><strong>2.字符串变量名.charCodeAt(索引值） 返回对应位置字符的ASCII码 用于判断用户按键</strong></p>
<p>console.log(str.charCodeAt(0)); </p>
<p><strong>3.变量名[索引值]</strong></p>
<p>console.log(str[1]); </p>
<p><strong>字符串连接</strong></p>
<p>字符串1.concat（字符串2）；</p>
<p>字符串1.concat（字符,字符,...）；</p>
<p>一般用加号</p>
<p><strong>字符串截取</strong></p>
<p><strong>字符串.substr（截取起始位置，截取的字符数） 不改变原字符串</strong></p>
<p>var str = '改革春风吹满地'; console.log(str.substr(2,2)); </p>
<p><strong>字符串替代</strong></p>
<p><strong>字符串.replace（‘被替换的字符’，‘替换为的字符’）</strong></p>
<p>返回的是新修改后的字符串，原字符不变</p>
<p>var str='andy'; console.log(str.replace('y','d')); // 有一个字符串'abcoefoxyozzopp' 要求把所有o替换为* var str1='abcoefoxyozzopp'; for(i=0;i<str1.length;i++) {     str1 = str1.replace('o','*'); } </p>
<p><strong>字符串转为数组</strong></p>
<p><strong>字符串.split（‘分隔符’）</strong></p>
<p>原字符串用什么分割，就用什么做分隔符 不改变原字符串</p>
<p>var str1 = 'red,pink,blue'; console.log(str1.split(',')); var str3 = 'red&pink&blue'; console.log(str3.split('&')); </p>
<p><strong>字符串大小写转换</strong></p>
<p><strong>字符串.toUpperCase（） 将字符串转为大写</strong></p>
<p><strong>字符串.toLowerCase（） 将字符串转为大写</strong></p>
<p><strong>注：字符串大小比较是按对应字母一个一个比</strong></p>
<p><strong>去除字符串左右的空格</strong></p>
<p><strong>字符串.trim()</strong></p>
<p><strong>可用来去除表单只填入空格时造成的bug</strong></p>
<p><strong>判断字符串开头结尾</strong></p>
<p><strong>字符串.startsWith('xxx');  判断str字符串是否以xxx开头</strong></p>
<p><strong>字符串.endsWith('xxx');  判断str字符串是否以xxx结尾</strong></p>
<p>let str = 'hello myworld'; // startsWith 判断字符串是否以某字符串开头 返回布尔值 console.log(str.startsWith('he'));//true // endsWith 判断字符串是否以某字符串结尾 返回布尔值 console.log(str.endsWith('rld'));//true </p>
<p><strong>重复某个字符串</strong></p>
<p><strong>字符串.repeat(n) 将字符串str重复n次，返回新的，不改变旧的</strong></p>
<p>let str = 'x'.repeat(5); console.log(str); str1 = str.repeat(2); console.log(str1); </p>
<p><strong>类方法</strong></p>
<p><strong>根据ASCII码返回字符串</strong></p>
<p><strong>String.fromCharCode(***</strong>num1<strong>***,</strong> <strong><em>...**</em></strong>,** <strong><em>numN**</em></strong>)**</p>
<p>console.log(String.fromCharCode(78));//N </p>
<p><strong>简单和复杂数据类型</strong></p>
<p><strong>简单数据类型（基本数据类型或值类型）：存储时变量中存放的是值本身，因此叫值类型，如number、boolean、undefined、null。都具有固定的内存大小</strong></p>
<p><strong>其中null的返回类型是Object，因此一般可先用来定义对象</strong></p>
<p>var timer = null; console.log(typeof null); //结果为object </p>
<p>如果有个变量打算存储为对象但没想好放什么属性和行为，那么就可以先设置为null类型</p>
<p><strong>复杂数据类型（引用类型）：变量中存储的仅仅是地址，如对象及其特殊类型数组和函数</strong></p>
<p><strong>其中字符串不能很好地适合基本类型和引用类型的二分法。因为字符串不是对象，被当做基本类型，而字符串又有任意的长度，所以也可以被认为是引用类型。字符串是通过传值来比较</strong></p>
<p><strong>堆和栈</strong></p>
<p><strong>栈：存放简单数据类型，由操作系统自动分配释放存放函数的参数值、局部变量的值等。简单数据类型直接查找存放在栈中的变量的值（简单数据>栈>变量>值）</strong></p>
<p><strong>堆：存放复杂数据类型，一般由程序员分配释放。复杂数据类型通过存放在栈中的变量中的地址找到存放在堆中的值（复杂数据>栈>变量>地址>堆>值）</strong></p>
<p><strong>简单数据类型的传参（传值）</strong></p>
<p><strong>函数的形参可以看做一个变量，当把一个变量传给函数形参就等于把变量的值复制一份给形参。所以对函数内变量的修改不会影响外部变量</strong></p>
<p><strong>复杂数据类型的传参（传址）</strong></p>
<p><strong>函数的形参可以看做一个变量，当把一个变量传给函数形参就等于把变量存放的堆地址复制一份给形参，即形参和实参保存的是同个堆地址，所以操作的是同一个对象。</strong></p>

        </div>
        
            <div class="busuanzi">
                <span id="busuanzi_container_page_pv">阅读量<span id="busuanzi_value_page_pv"></span>次</span>
                <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            </div>
        
    </article>
    <div class="outline"><span class="fa fa-list"></span></div>
</div>
                    <pointer href="javascript:void(0);" class="arrow fa fa-arrow-up"></pointer>
<pointer href="javascript:void(0);" class="arrow fa fa-arrow-down"></pointer>

            </main>
            <aside class="aside">
    <div class="aside-content">
        <div class="aside-avatar"><img src="/images/maomi.jpg" alt="lhl"></div>
        <div class="aside-author">lhl</div>
        <div class="aside-description">爱玩植物大战僵尸</div>
        <ul class="aside-contact clearFix">
            <li><span class="fa fa-github"></span><a href="https://github.com/Mikasayooooo" target="_blank" rel="noopener">Github</a></li>
            <li><span class="fa fa-envelope"></span><a href="javascript:void(0);">1056205431@qq.com</a></li>
            <li><span class="fa fa-weixin"></span><a href="javascript:void(0);"><img src="" alt="扫描微信二维码，加我哦！"></a></li>
        </ul>
    </div>
</aside>
                <div class="toolbar"><span class="fa fa-th"></span></div>
                    <div class="search"><span class="fa fa-search"></span></div>
                        <div id="particles-js"></div>
                            
<script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/js/jquery.min.js"></script>

                                
<script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/js/particles.min.js"></script>

                                    
<script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@9.0/js/app.js"></script>

                                        
<script src="https://cdn.jsdelivr.net/gh/meethigher/cdn@11/js/layer/layer.js"></script>

                                            
<script src="/js/meethigher.js"></script>

                                                
<script src="/js/toolbar.js"></script>

    </body>

</html>