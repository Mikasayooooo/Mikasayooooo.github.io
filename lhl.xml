<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js基础</title>
    <url>/2020/03/12/js%E5%9F%BA%E7%A1%80-1/</url>
    <content><![CDATA[<p><strong>JS概论</strong></p>
<p>HTML/CSS-标记语言</p>
<p>JS脚本语言-编程类语言</p>
<p><strong>浏览器分成两部分，渲染引擎和JS引擎</strong></p>
<p>渲染引擎:用来解析HTML与CSS，俗称内核,比如chrome的blink</p>
<p>JS引擎：JS解释器，用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的V8</p>
<p>浏览器本身并不会执行JS代码，而是通过内置JavaScript引擎来执行JS代码，JS引擎执行代码时逐行解释每一句源码（转换为机器语言二进制），然后由计算机去执行</p>
<p><strong>解释性语言：进行时立即解释执行的语言 如js</strong></p>
<p><strong>编译性语言：必须通过编译生成中间代码后才执行的语言 如java、c</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cfffb8145a3d84ffd90c259d05fae27c6%5C91c376eaf8dc4cf7ac0825ecdf328d19.jpg" alt="img"></p>
<p><strong>JS组成：ECMAscript（js语法）、DOM（页面文档对象模型）、BOM（浏览器对象模型）后两者即合称API</strong></p>
<p><strong>ECMAscript:规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准</strong></p>
<p><strong>JavaScript程序的执行</strong></p>
<p><strong>出现在<script>和</script>标记对之间的javascript语句按照它们在脚本中出现的顺序来执行。当一个文件有多个脚本的时候，脚本按照它们出现的顺序来执行（除非脚本带有defer属性）。<script>标记中的JS代码作为文档载入和解析过程的一部分来执行</strong></p>
<p><strong>JS词法结构</strong></p>
<p><strong>JS注释</strong></p>
<p><strong>单行注释：//</strong></p>
<p><strong>多行注释：/*......*/</strong></p>
<p>// 1.单行注释 ctrl+/ /<em>2.多行注释  2.多行注释  ctrl+shift+/</em>/ </p>
<p><strong>标识符、关键字、保留字、直接量</strong></p>
<p><strong>标识符：开发人员为变量、属性、函数、参数取的名字（标识符不能是关键字或保留字）</strong></p>
<p><strong>关键字：js本身已经使用了的字</strong></p>
<p><strong>保留字：为后面预留的关键字 如boolean byte char int等</strong></p>
<p><strong>字面量(直接量):程序中直接显示出来的数据值</strong></p>
<p>数字字面量：8，9，10</p>
<p>字符串字面量：“黑马程序员” “大前端”</p>
<p>布尔字面量：true false</p>
<p><strong>js命名规则</strong></p>
<p><strong>标识符命名规则</strong></p>
<p><strong>1.必须要有意义</strong></p>
<p><strong>2.变量一般用名词</strong></p>
<p><strong>3.函数一般用动词</strong></p>
<p><strong>4.不能与其他关键字同名</strong></p>
<p><strong>操作符规范</strong></p>
<p>操作符左右两侧各保留个空格</p>
<p><strong>单行注释//后加一个空格再写注释</strong></p>
<p><strong>末尾大括号要对齐其父元素</strong></p>
<p><strong>js嵌入HTML</strong></p>
<p><strong>行内式：放置在HTML事件处理程序中</strong></p>
<input type="botton" value="tangbohu" onclick="alert('秋香姐')"> 

<p>注意：</p>
<p><strong>1.可以将单行或少量JS代码写在HTML标签的事件属性中（以on开头的属性），如：onclick</strong></p>
<p><strong>2.注意单双引号的使用：在HTML中我们推荐使用双引号，JS中使用单引号</strong></p>
<p><strong>3.可读性差</strong></p>
<p><strong>4.引号易错，易混淆</strong></p>
<p><strong>5.特殊情况下使用</strong></p>
<p><strong>内联式（直接写在html文件中，一般写在body标签中所有元素后面）</strong></p>
<script>
    alert('sssssss');
</script>



<p><strong>外联式：放置在由<script>标签的src属性指定的外部js文件中</strong></p>
<script type="text/javascript" src="my.js">此处不可写代码</script>

<p><strong>注意：引用外部js文件的script标签中间不可以写代码</strong></p>
<p>执行顺序就是他们在文档中出现的顺序</p>
<p><strong>指定脚本语言</strong></p>
<meta http-equiv="Content-Script-Type" content="text/javascript">

<p><strong>一般浏览器会假设js为默认脚本化语言，如果没有指定默认语言，或者想覆盖默认语言，可以使用type属性</strong></p>
<script type="text/javascript">



**script标记的属性defer、async**

脚本的执行在默认情况下是同步和阻塞的。但是如果有了属性defer或者async，情况会发生变化。

**defer作用：浏览器解析遇到带有defer属性的script标记时，延迟该脚本的执行。文档的载入和解析完成再继续执行**

**async作用：浏览器可以尽快执行脚本，不用在下载脚本时阻塞文档解析。即一边下载js一边解析文档，js**

**如果两者同时都有，那么会遵从async而忽略defer** 



**JS输入输出语句**

**alert（msg）   浏览器弹出警示框** 

**console.log(msg)    浏览器控制台打印输出信息**  

**prompt(info)  浏览器弹出输入框，用户可以输入，输入的是字符串**

**confirm（msg） 浏览器弹出确认框，点击确认返回true，否则返回false**

<script type="text/javascript">
        // 这是一个输入框
        prompt('请输入您的年龄');
        // 弹出警示框 输出展示给用户的
        alert('输入结果是：');
        // console 控制台输出 便于测试
        console.log('我是程序猿');
          //弹出确认框
          var w = confirm("你确定吗?")；
</script>

<p>注意：confirm、prompt、alert都会产生阻塞，但他们弹出时，代码会停止运行。</p>
<p><strong>JS变量</strong></p>
<p><strong>声明和初始化</strong></p>
<p><strong>1.声明变量</strong></p>
<p>// 声明变量  var age; //声明一个名为age的变量 </p>
<p>var=variable</p>
<p><strong>2.赋值</strong></p>
<p>age = 10；  </p>
<p>=表示把右边的值赋予左边的值</p>
<p><strong>变量的初始化</strong></p>
<p>var age=10； </p>
<p><strong>变量语法扩展</strong></p>
<p>var myname='pink老师';         console.log(myname);         myname='pink';         console.log(myname); </p>
<p>变量值只取就近一个</p>
<p><strong>声明多个变量</strong></p>
<p> var age=18, address='火影村', gz=2000; </p>
<p><strong>声明变量的特殊情况</strong></p>
<p> // 1.只声明不赋值 结果为undefined var sex; console.log(sex); // 2.不声明不赋值 直接使用某个变量 结果报错 // console.log(tel); // 不声明直接赋值 结果正确 不推荐  qq =110; console.log(qq); </p>
<p><strong>变量命名规范</strong></p>
<p><strong>1.由字母数字下划线美元符号构成，不能有横杠！！！</strong></p>
<p><strong>2.区分大小写</strong></p>
<p><strong>3.不能数字开头</strong></p>
<p><strong>4.不能是关键字、保留字</strong></p>
<p><strong>5.变量名必须有意义</strong></p>
<p><strong>6.遵守驼峰命名法</strong></p>
<p><strong>7.对于内部使用的函数变量可以用下划线开头结尾的格式命名</strong>  </p>
<p><strong>作用域（变量起作用的范围，可以提高程序的可靠性，减少命名冲突）</strong></p>
<p><strong>作用域类型</strong></p>
<p>1.全局作用域：整个script标签内 或是一个单独的js文件</p>
<p>2.局部作用域：在函数内部，代码名字只在函数内部起效果和作用</p>
<p><strong>根据作用域的不同，变量可分为：1.全局变量 2.局部变量</strong></p>
<p>1.全局变量：在全局起作用的变量</p>
<p>2.局部变量：在局部作用域下的变量（函数内部的变量） 函数形参亦可以看做局部变量</p>
<p>从执行效率看</p>
<p>1.全局变量只有浏览器关闭时才会销毁，比较占内存资源</p>
<p>2.局部变量在程序执行完毕时即销毁</p>
<p><strong>现阶段js没有块级作用域（即花括号包含之内）：函数中声明的所有变量，无论是在那里声明在整个函数中都是有定义的，因为变量提升的原因</strong></p>
<p><strong>全局对象和调用对象</strong></p>
<p><strong>全局对象：当js解释器开始运行时，它首先要做的是在执行任何js代码前创建一个全局对象，而全局变量就是这个全局对象的属性。在客户端JS（嵌入网页的JS）中，这个全局对象就是Window对象</strong></p>
<p><strong>调用对象：每调用一次函数时，会在该函数作用域链前加一个调用对象。函数的参数和局部变量是作为调用对象的属性而存储的。用一个完全独立的对象来存储局部变量使JS可以防止局部变量覆盖同名的全局变量的值</strong></p>
<p><strong>作用域链（为一个对象列表或对象链。在一个**</strong>非嵌套函数中，作用域链由这个函数的调用对象和全局对象组成<strong>**）</strong></p>
<p>内部函数访问外部函数的变量，采取的是<strong>链式查找</strong>的方式根据就近原则来决定取那个值</p>
<script type="text/javascript">
    var num = 10;
    function fn() {
        var num = 20;
        function fun() {
            console.log(num);
        }
        fun();
    }
    fn();
</script>   结果是20



<p><strong>垃圾收集</strong></p>
<p>JavaScript每次创建字符串数组或对象时，解释器都必须f分配内存储存实体</p>
<p>与C、C++不同，js有<strong>垃圾收集</strong>的机制，解释器可以检测何时程序不再使用一个对象，<strong>当确定了对象是无用的时候，会自动释放其占用的内存</strong></p>
<p><strong>数据类型（占用内存大小不同）</strong></p>
<p><strong>js是一种弱类型或者说动态语言，不用提前声明变量的类型，在程序运行过程中，类型会自动被确定，js的变量数据类型只有被赋值后才被确定</strong></p>
<p><strong>相同的变量可用于不同的数据类型</strong></p>
<p><strong>简单数据类型：3种基本数据类型—数字型、字符串型和布尔型，两种小数据类型—null、undefined，还有ES6新增的symbol</strong></p>
<table>
<thead>
<tr>
<th>简单数据类型</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>Number</td>
<td>数字型，包含整型值和浮点型值，如21，0.21</td>
<td>0</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔型，如true、false</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>字符串类型，如“张三”</td>
<td>“”</td>
</tr>
<tr>
<td>Undefined</td>
<td>var a; 声明但没赋值 此时a=undefined</td>
<td>undefined</td>
</tr>
<tr>
<td>Null</td>
<td>var a=null; 声明了变量a为空值</td>
<td>null</td>
</tr>
</tbody></table>
<p><strong>复杂数据类型:对象(object)、数组(array)、函数(function)、日期(Date)、正则表达式(RegExp).本质上都是对象</strong></p>
<p><strong>数字型Number</strong></p>
<p>var num=10; var PI=3.14; var num1=010;    // 数字前面加0，代表八进制 console.log(num1);  // 数字前面加0x，代表16进制 var num2=0x9; var num4=0xa; // 最大值 console.log(Number.MAX_VALUE); // 最小值 console.log(Number.MIN_VALUE);  // 无穷大 console.log(Number.MAX_VALUE * 2);  /<em>输出infinity 无穷大</em>/ // 无穷小 console.log(-Number.MAX_VALUE * 2); /<em>输出-infinity 无穷小</em>/ // 非数值 NaN console.log('ab'-2); /<em>输出NaN</em>/ </p>
<p><strong>isNaN（）；  用来判断非数字 数字返回false 非数字返回true</strong></p>
<p>console.log(isNaN(12));  结果为false console.log(isNaN('dada'));  结果为true </p>
<p><strong>变量.toFixed（n）； 将变量保留n位小数</strong></p>
<p>var num =2.312313; console.log(num.toFixed(3)); // 2.312 </p>
<p><strong>字符串型（不是对象）</strong></p>
<p>语法:双引号或单引号（推荐）</p>
<p>嵌套：外双内单或者外单内双</p>
<p><strong>转义符（以\开头）</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Ce041c65ea275406e8949bbe4d31de77a%5C2635a5dd1182438b98d1fd0ff5f57ebf.jpg" alt="img"></p>
<p><strong>字符串的length属性（用于检测字符串长度）</strong></p>
<script type="text/javascript">
    // 检测获取字符串的长度
    var str = 'my name is andy';
    console.log(str.length);
</script>



<p><strong>字符串拼接</strong></p>
<p>多个字符串之间可以用+拼接，拼接方式为字符串+任何类型=拼接之后的新字符串</p>
<p>数值型和字符型之间也可以相加</p>
<p>口诀：数值相加，字符相连</p>
<script type="text/javascript">
    console.log('woshi'+'haha'); 结果是woshihaha
    console.log('wo'+12);    结果是wo12
    console.log('so'+true);        结果是sotrue
    console.log(12+12);    结果是24
    console.log('12'+12);    结果是1212
    var age=18;
    console.log('陈佳炜'+age+'岁'); 结果是陈佳炜18岁
    age=age+1;
    console.log('陈佳炜'+age+'岁'); 结果是陈佳炜19岁
</script>



<p><strong>布尔型</strong></p>
<p>布尔型有两个值：true和false，其中true表示真，false表示错</p>
<p>布尔型和数字型相加时,true为1，false为0</p>
<p><strong>Undefined</strong></p>
<p><strong>如果使用了一个**</strong>并未声明的变量<strong><strong>时，或者使用了</strong></strong>已经声明但还没有赋值的变量<strong><strong>时，又或者</strong></strong>使用了一个并不存在的对象属性<strong>**时，返回的就是undefined</strong></p>
<p>定义方式</p>
<p>var str; var str=undefined console.log(str+'aa'); 结果为undefinedaa console.log(str+1); undefined和数字相加，最后结果是NaN </p>
<p><strong>布尔环境中，它会转为false。数字环境中，会被转为NaN。字符串环境中，转为“undefined”</strong></p>
<p><strong>Null</strong></p>
<p><strong>即不是有效的对象、数组、数字、字符串和布尔值</strong></p>
<p>定义方式</p>
<p>var b=null; console.log(b); 结果为null console.log(b+'dadad'); 结果为nulldadad console.log(b+1);  结果为1 </p>
<p><strong>布尔环境中，它会转为false。数字环境中，会被转为0。字符串环境中，转为“null”</strong></p>
<p><strong>数据类型转换</strong></p>
<p><strong>转为字符型</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C02d6732e0bfa45c7b8f1f9367ea07aad%5C46e2a276128742e2a6366dbf2fdb0c38.jpg" alt="img"></p>
<p>用法</p>
<p>变量.toString() var num=10; var str=num.toString(); console.log(str); console.log(typeof str);  // console.log(typeof num);  // 利用 String()  // console.log(typeof String(num));  // 利用拼接字符串的方法  console.log(typeof (num+'')); </p>
<p><strong>toString（）可加参数，用来指定转换的基数，如为2，则转为二进制，如为8，则转为八进制，默认为10</strong></p>
<p>var num = 190; num = num.toString(2); console.log(num);// 1011110 </p>
<p><strong>前两种了解即可。推荐使用第三种，亦称为**</strong>隐式转换**</p>
<p><strong>转为数字型（重点）</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C750209ac5e81494b9539319ea9fc2c2a%5Ceb532fea5499406ca0f10e72bbc72dc8.jpg" alt="img"></p>
<p><strong>重点掌握parseInt() parseFloat()</strong></p>
<p>parseInt（）、parseFloat（）会从<strong>字符串开始处</strong>转换和返回<strong>任何的数字</strong>，自动忽略舍去<strong>非数字部分（前提是数字开头）</strong></p>
<p>console.log(parseInt("88 woshi"));// 88 console.log(parseInt("aa 88 woshi"));//NaN </p>
<p>parseInt可以解析<strong>“0x”或“0X"开头的数字</strong>，也可以接受另一个参数指定要解析的数字的基数<strong>(不能解析0开头的数字，除非显性地指定所使用的基数）</strong></p>
<p>console.log(parseInt("ff",16)); </p>
<p>parseInt(变量)  只能转为整数型 var age= prompt('请输入年龄'); console.log(parseInt(age)); console.log(parseInt('3.14'));  //3 取整 console.log(parseInt('120px'));  //会取消px单位 // parseFloat 可以吧字符型的转化为数字型 得到是小数 浮点数 console.log(parseFloat('3.14')); // Number() var str='123'; console.log(Number(str)); // 隐式转换  可以利用- * / 三种符号 console.log('12'-0); </p>
<p>注<strong>:Number()只对10十进制数字有限</strong></p>
<p><strong>转化为布尔型</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cbe1fee6ed519439eb34b329b97e9bee3%5Cc0325a464fa644f2aeae6040cf8431b7.jpg" alt="img"></p>
<p>代表空、否定的值都转化为false，如‘’，0，null，NaN，undefined。其他都转化为true</p>
<p>console.log(Boolean('')); console.log(Boolean(0)); console.log(Boolean(null)); console.log(Boolean(NaN)); console.log(Boolean(undefined)); console.log(Boolean(123)); </p>
<p><strong>运算符</strong></p>
<p>浮点数运算精确度远不如整数，不能直接拿浮点数比较是否相等</p>
<p><strong>表达式：由数字、运算符、变量组成的式子</strong></p>
<p>返回值：表达式返回的值</p>
<p><strong>递增递减运算符</strong></p>
<p>递增运算符（++） 递减运算符（--）</p>
<p>放在变量前面为前置递增 后面为后置递增</p>
<p>前置递增：先运算再取值</p>
<p>后置递增：先取值再运算</p>
<p>单独使用时两者结果相同</p>
<p><strong>比较运算符</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cb11bca1efc004a7a8a310a2372badd16%5C6564ed2d01f54ce7ab07d02dbad1824e.jpg" alt="img"></p>
<p><strong>= 赋值  == 判断（会转型）  ===全等（**</strong>不转型,即判断数据类型和值是否全部相等，对于对象数组函数来说则是判断是否引用同一个地址的对象数组函数<strong>**）</strong></p>
<p><strong>instanceof运算符（判断对象类型）</strong></p>
<p>instance：实例</p>
<p><strong>用于判断是否是某种特殊对象（数组、对象、日期）的实例</strong></p>
<p><strong>要求左边是对象，右边是一个类的名字</strong></p>
<p>var d = newDate(); d instanceof Object;//true </p>
<p><strong>注：instanceof是通过原型对象来判断一个实例属不属于某个构造函数创建的，而不是通过构造函数的名字</strong></p>
<p><strong>利用typeof获取变量数据类型（判断基本类型）</strong></p>
<p><strong>语法：typeof 变量</strong></p>
<p><strong>返回的是字符类型的小写的数据类型名称 'undefined' 'string' 'number' 'function''boolean',对于包装对象和DOM获得的元素返回的都是'object'对象，null和数组返回的是object</strong></p>
<p>var num=10; console.log(typeof num); var str='pink'; console.log(typeof str); var flag=true; console.log(typeof flag); var vari=undefined; console.log(typeof vari); var timer=null; console.log(typeof timer); var age=prompt('请输入年龄'); console.log(typeof age); </p>
<p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th>&&</th>
<th>与</th>
</tr>
</thead>
<tbody><tr>
<td>||</td>
<td>或</td>
</tr>
<tr>
<td>！</td>
<td>非</td>
</tr>
</tbody></table>
<p>如果是布尔值参与逻辑运算，则结果为布尔值</p>
<p>如果是具体数值或表达式参与运算，则发生逻辑中断，其中具体数值代表真，0 ‘’ null undefined NaN代表假</p>
<p>短路运算原理：当有多个表达式时,左边的表达式可以确定结果时，就不再运算右边的表达式的值</p>
<p><strong>表达式1 && 表达式2</strong></p>
<p><strong>如果第一个为真,不足以确定结果，那么就返回表达式2</strong></p>
<p><strong>如果第一个为假，足以确定结果，那么就返回表达式1</strong></p>
<p>console.log(0 && 456);   结果为0 console.log(123 && 456);  结果为456 </p>
<p><strong>表达式1 || 表达式2</strong></p>
<p><strong>如果第一个为真,足以确定结果，那么就返回表达式1</strong></p>
<p><strong>如果第一个为假，不足以确定结果，那么就返回表达式2</strong></p>
<p>console.log(123 || null);  结果为123 console.log(undefined || 456);   结果为456 var num=0; console.log(123 || console.log(num);   结果为0 </p>
<p><strong>赋值运算符</strong></p>
<p>=  赋值  后面赋值给前面</p>
<p>+=x   每次加x  num+=5；  num=num+5</p>
<p>-=x   每年减x  num-=5 ；    num=num-5</p>
<p>*=x 每次乘x</p>
<p>/=x 每次除x</p>
<p>%=x 每次除x取余</p>
<p><strong>运算符优先级</strong></p>
<p>1.小括号</p>
<p>2.一元运算符 ++ -- ！</p>
<p>3.算术运算符 先*/% 再 + -</p>
<p>4.关系运算符</p>
<p>5.相等运算符</p>
<p>6.逻辑运算符 先&& 后||</p>
<p>7.赋值运算符 =</p>
<p>8.逗号运算符， </p>
<p><strong>语句</strong></p>
<p><strong>三种结构</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cf4ef9b5f53a1444d9459dff8adb6fac7%5Ca3c68709572f43c19bf097e3c5b76ca6.jpg" alt="img"></p>
<p><strong>顺序结构：按照代码先后顺序，依次执行</strong></p>
<p><strong>分支结构：根据不同的条件，执行不同的路径代码（if、while）</strong></p>
<p><strong>if分支语句</strong></p>
<p>语法：if（条件表达式）{ 执行语句；}</p>
<p>如果条件表达式结果为真，则执行大括号里面的执行语句</p>
<p>如果条件表达式为假，则跳过if执行后面的代码</p>
<p>if() {} else {}</p>
<p>if（） {} else if {} else if {} else{} 先判断第一个 不符合则判断下一个</p>
<p><strong>三元表达式（由三元运算符？ ： 组成的表达式）</strong></p>
<p>语法结构</p>
<p>条件表达式？ 表达式1:表达式2  如果条件表达式结果为真，则返回表达式1的值，如果为假则返回表达式2</p>
<p><strong>switch语句</strong></p>
<p>switch（表达式） {</p>
<p>case value1： 执行语句1；break；</p>
<p>case value2： 执行语句2；break；</p>
<p>。。。</p>
<p>default：执行最后的语句；</p>
<p>}</p>
<p>匹配case的值，如果匹配，则运行该case里的值，如果都不匹配，则执行default里的值</p>
<p><strong>表达式里的值和case里的值相等是用全等===判定的，即必须是值和数据类型完全一致才可以</strong></p>
<p><strong>必须要有break，否则会执行下一个case</strong></p>
<p><strong>if else if 和switch的区别</strong></p>
<p><strong>1.前者一般用判断范围 后者一般用于确定值</strong></p>
<p><strong>2.前者需要判断多次，后者进行判断后直接执行到程序的条件语句，效率较高</strong></p>
<p><strong>3.分支较少时前者效率高</strong></p>
<p><strong>4.分支多时后者效率高且结构更清晰</strong></p>
<p><strong>循环结构（可重复执行一些代码）</strong></p>
<p><strong>for循环结构</strong></p>
<p>for（初始化变量；条件表达式；操作表达式) { 循环体；}</p>
<p>for()</p>
<p>for() {}</p>
<p>外层循环一次，里面的循环执行全部</p>
<p><strong>断点调试</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C2843de02167643a78053a781447b375a%5Cb34266e0c9ab40d79eb72e08234fd5d9.jpg" alt="img"></p>
<p><strong>while循环结构</strong></p>
<p>while（）{}</p>
<p>记得加入计数器，防止死循环</p>
<p><strong>do{} while（）循环</strong></p>
<p>先执行一次语句，再判断，若正确，则继续执行，否则退出</p>
<p>即循环体至少执行一次</p>
<p>总结：一般若与数字相关，常用for。while和dowhile可以执行更加复杂的循环。while先判断再执行，dowhile先执行再判断</p>
<p><strong>跳转语句</strong></p>
<p><strong>continue</strong></p>
<p>遇到continue就停止本次循环，直接跳到i++，不再执行循环体内continue后面语句</p>
<p>for (var i =1;i<=5;i++) {     if (i==3) {         continue;     }     console.log('我正在吃第'+i+'个包子'); } </p>
<p>结果</p>
<p>我正在吃第1个包子</p>
<p>我正在吃第2个包子</p>
<p>我正在吃第4个包子</p>
<p>我正在吃第5个包子</p>
<p><strong>break</strong></p>
<p>遇到break直接跳出此循环所属的for语句的所有循环</p>
<p>for(var i=1;i<=5;i++) {     if(i==3) {         break;     }     console.log('我正在吃第'+i+'个包子') } </p>
<p>结果</p>
<p>我正在吃第1个包子</p>
<p>我正在吃第2个包子</p>
<p><strong>throw</strong></p>
<p>用于抛出异常，用信号通知发生了错误或者异常状况</p>
<p>异常：发生了某种异常情况或错误时产生的一个信号。</p>
<p>语法格式：</p>
<p>throw expression；</p>
<p>expression可以使任意类型，一般为Error对象</p>
<p>function twoArg(o,t) {     if(arguments.length !== 2)          throw new Error('必须是两个参数'); } twoArg(1); </p>
<p>注意:当抛出异常时，JS解释器会停止当前正在执行的逻辑，跳转到最近的异常处理程序（即后面try/catch/finally中catch语句编写的程序）</p>
<p><strong>try/catch/finally</strong></p>
<p>try用于检查抛出异常</p>
<p>catch用于抓住异常，其参数便是try抛出的值</p>
<p>finally内的代码无论如何总会执行</p>
<p>try {             var n = prompt('enter a number');             // var t = prompt('enter a number');             if(n == 1) {                 throw 'wocao';             }         }         catch(e) {             alert(e);//wocao         } </p>
<p>注意：</p>
<p>1.try后面至少要跟随一个catch或者finally</p>
<p>2.catch的参数有局部作用域，只在catch语句中有效</p>
<p>3.如果没有catch从句，执行finally后会向上传播异常，直到找到能处理这个异常的catch从句</p>
<p><strong>数组（一组数据的集合）</strong></p>
<p><strong>创建方式：</strong></p>
<p><strong>1.利用new关键字创建数组</strong></p>
<p>var arr = new Array(); </p>
<p><strong>2.利用数组字面量创建数组</strong></p>
<p>var arr = ['a','b','c','d','e']; var arr = [1，2，‘dada'，true]; var arr=[]; </p>
<p>注意</p>
<p><strong>1.数组里面可以放任何数据类型</strong></p>
<p><strong>2.数组里面的数据称为数组元素</strong></p>
<p><strong>数组的索引</strong></p>
<p><strong>索引：用来访问数组元素的序号（**</strong>从0开始，最大为2^32 - 1<strong>**）</strong></p>
<p>数组的长度是元素个数，不要跟索引号混淆</p>
<p><strong>数组的遍历</strong></p>
<p><strong>遍历：就是把数组中的所有元素从头到尾访问一次；</strong></p>
<p>数组名.length:动态监测数组元素的个数，一般循环遍历时长度都用这个来表示</p>
<p>for(i=0;i<date.length;i++) { alert(date[i]); } </p>
<p><strong>数组元素增加</strong></p>
<p><strong>1.通过修改length新增数组元素</strong></p>
<p>先修改数组长度，再对新增元素赋值</p>
<p>若修改后的长度<原先的长度，则原数组会被截取。若修改后的长度>原先的长度，则原数组会添加多余个数的undefined</p>
<p> arr.length=5; arr[3]=4; arr[4]=5; </p>
<p><strong>2.通过修改数组索引的方式增加数组元素</strong></p>
<p>直接对未赋值的数组元素赋值，若赋值的索引号已被占用，则会被替换为新的元素值</p>
<p>var arr = [1, 2, 3]; arr[3]=4; </p>
<p><strong>注意：不要对数组名直接赋值，否则会清除所有数组元素</strong></p>
<p><strong>函数（封装了一段可被重复调用执行的代码块，通过函数可以实现大量代码的重复使用)</strong></p>
<p><strong>函数使用步骤：1.声明函数 2.调用函数</strong></p>
<p><strong>1.声明函数</strong></p>
<p><strong>声明方式1：</strong></p>
<p><strong>function 函数名（参数1，参数2，...）{ 函数体；}</strong></p>
<p><strong>注意：</strong></p>
<p><strong>1.function为声明函数的关键字，全部小写</strong></p>
<p><strong>2.函数名一般为动词，代表此函数要做什么</strong></p>
<p><strong>3.函数声明后被调用才能执行，不调用不执行</strong></p>
<p><strong>4.函数声明一般出现在js代码的顶层，也可以嵌套在其他函数中，但是只能嵌套在那些函数顶层中，不能出现在if，while或其他语句中</strong></p>
<p><strong>5.使用可选参数设计函数时，应该确保把可选的参数放参数列表的末尾</strong></p>
<p>function sayHi() {     alert('hi'); }     </p>
<p><strong>声明方式2：</strong></p>
<p><strong>var 变量名=function（参数1，参数2，...）{}； （匿名函数）</strong></p>
<p> var fun = function() {      console.log('我是傻逼');  } </p>
<p><strong>2.函数调用</strong></p>
<p><strong>函数名()；</strong></p>
<p>sayHi（）； </p>
<p>或者</p>
<p><strong>变量名（）; 针对第二种声明方式</strong></p>
<p>fun(); </p>
<p>注意：</p>
<p>调用函数时一定记得写小括号</p>
<p><strong>函数的参数：形参 实参</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Ce42fdae07684433f888f863dcdc1f29a%5C2859bb1fd22540a9a9a09ae212cc4a4a.jpg" alt="img"></p>
<p>多个参数之间逗号隔开</p>
<p><strong>如果实参个数多于形参个数，会取到形参的个数</strong></p>
<p><strong>如果实参个数小于形参的个数，没有赋值的形参则为undefined，结果为NaN</strong></p>
<p><strong>调用数组时直接写数组名字或者整个数组元素即可</strong></p>
<p><strong>函数返回值</strong></p>
<p>函数只是实现某种功能，最终结果需要return返回数值，return只能返回一个值</p>
<p>函数如果没有return，返回的是undefined</p>
<p><strong>return也有终止函数的功能</strong></p>
<p>可以利用数组实现返回多个值</p>
<p>function getResult(num1,num2) {     return [num1+num2, num1 - num2,num1 * num2, num1 / num2]; } var re= getResult(1,2); console.log(re); </p>
<p><strong>arguments的使用（存储函数传递的所有实参）</strong></p>
<p><strong>arguments是Arguments对象的实例，是当前函数的一个内置对象，所有函数都内置了一个arguments对象，**</strong>arguments只能在函数中调用，<strong><strong>可以按照数目获取函数的</strong></strong>实参<strong><strong>的参数值（</strong></strong>调用函数时写的参数而不是定义函数时写的形参<strong>**）</strong></p>
<p>当不确定有多少个参数传递的时候，可以用arguments来获取。</p>
<p>function fn() {     console.log(arguments); } fn(1,2,3); </p>
<p>arguments是一个伪数组，可以进行遍历，特点如下：</p>
<p><strong>1.具有length属性</strong></p>
<p><strong>2.按索引方式储存数据</strong></p>
<p><strong>3.不具有数组的push、pop等方法</strong></p>
<p><strong>arguments的属性</strong></p>
<p><strong>arguments.callee:返回arguments所在的函数</strong></p>
<p>function whoIsCalling() {     console.log(arguments.callee); } whoIsCalling();//返回whoIsCalling函数的代码 </p>
<p>该属性可用来实现回调</p>
<p><strong>在JS中，代码可以对函数进行操作。JS中的函数是真正的数据，可以被存储在变量中、数组和对象中，可以作为参数传递给其他函数</strong></p>
<p><strong>函数的属性方法</strong></p>
<p><strong>函数.length</strong></p>
<p><strong>返回函数**</strong>定义时<strong>**形参的个数</strong></p>
<p>function f(x,y) {     console.log(f.length);//2     console.log(arguments.length);//3 } f(1,2,3)； </p>
<p><strong>JS的预解析（小难点，看案例）</strong> </p>
<p><strong>js引擎运行分两步：</strong></p>
<p><strong>1.预解析：js引擎会把js里面所有的var 和 function提升到**</strong>当前作用域最前面**</p>
<p><strong>2.代码执行：按书写顺序依次执行代码</strong></p>
<p><strong>预解析分为：</strong></p>
<p><strong>1.变量预解析（变量提升）：把var提升到当前作用域的最前面，但不赋值</strong></p>
<p>function fun() {     console.log(num); } fun(); var num=10; 等价于 var num; function fun() {     console.log(num); } fun(); num=10;  fn(); var fn=function() {     console.log(11); } 等价于 var fn; fn(); fn=function() {     console.log(11); } </p>
<p><strong>2.函数预解析（函数提升）：把所有函数声明提升到当前作用域最前面，但不调用函数</strong></p>
<p>con(); function con() {     console.log(11); } 等价于 function con() { console.log(11); } con(); </p>
<p><strong>注意：var a=b=c=9； 预解析后等于var a；a=9；b=9;c=9; b和c变成全局变量</strong></p>
<p><strong>JS的对象</strong></p>
<p><strong>对象：**</strong>一组无序的相关属性和方法的集合，所有的事物 都是对象，<strong>**除了字符串、数字、true、false、null和undefined其他都是对象（事实上字符串数字布尔值可以被包装为包装对象）</strong></p>
<p><strong>对象由属性和方法构成</strong></p>
<p><strong>属性：事物的特征，在对象中用属性来表示（常用名词），属性值可以是任意的js表达式，等同于变量。</strong></p>
<p><strong>属性两种类型：</strong></p>
<p><strong>自有属性：直接在对象中定义的属性</strong></p>
<p><strong>继承属性：通过原型对象继承的属性</strong></p>
<p><strong>属性的三个特性：</strong></p>
<p><strong>值（value）：属性的值</strong></p>
<p><strong>可写（writable）：表明是否可以设置该属性的值</strong></p>
<p><strong>可枚举（enumerable）：表示是否可以通过for/in循环返回该属性</strong></p>
<p><strong>可配置（configurable）：表明是否可以删除或者修改该属性</strong></p>
<p><strong>方法：事物的行为，在对象中用方法来表示（常用动词），即存储在对象中的函数</strong></p>
<p><strong>对象有三种：1.自定义对象 2.内置对象 3.宿主对象 （前两者属于ECMAscript，后者属于客户端JavaScript）</strong></p>
<p><strong>创建对象</strong></p>
<p><strong>1.用字面量创建对象</strong></p>
<p><strong>var 对象名 = { 属性名： ‘属性值’，属性名： ‘属性值’，。。。}</strong></p>
<p>var obj = {     uname: '张三疯',     age: 18,     sex: '男',     sayHi: function() {         console.log('Hi');     } } </p>
<p><strong>调用对象</strong></p>
<p><strong>1.对象名.属性名</strong> </p>
<p><strong>2.对象名['属性名']（即作为关联数组的对象，允许动态地将任意数值和任意字符串关联在一起）</strong></p>
<p> console.log(obj.uname);  // (2) 第二种方法 对象名['属性名']  console.log(obj['age']); </p>
<p> <strong>变量、属性、函数、方法的区别</strong></p>
<p><strong>1.变量和属性都是用来存储数据，但变量需要声明属性不需要，变量可以直接写变量名调用，属性必须对象名.属性名调用，变量和属性基本等同</strong></p>
<p><strong>2.函数和方法都是实现某种功能。函数是单独声明且调用时是写函数名（）。方法在对象里声明且调用为 对象.方法（），对象中的函数即为方法</strong></p>
<p><strong>2.用new Object 创建对象</strong></p>
<p><strong>利用等号对属性进行赋值</strong></p>
<p>var obj = new Object(); obj.uname = '张三疯'; obj.age  = 18; obj.sex = '男'; obj.sayHi = function() {     console.log('Hi'); } </p>
<p><strong>调用对象</strong></p>
<p>console.log(obj.uname); console.log(obj.sex); obj.sayHi();     </p>
<p><strong>3.利用构造函数构造多个对象</strong></p>
<p><strong>构造函数：就是把对象里面一些相同的属性和方法抽出封装起来的函数，即构造对象的函数</strong></p>
<p>function 构造函数名(形参) {     this.属性 = 值;     this.方法 = function() {} } </p>
<p><strong>var 对象名 = new 构造函数名（实参）；</strong></p>
<p>function Star(uname,age,sex) {             this.name = uname;             this.age = age;             this.sex = sex;         }      var ldh = new Star('ldh',18,'male');  </p>
<p>注意点以及构造函数执行过程：</p>
<p><strong>1.构造函数名字首字母一般大写</strong></p>
<p><strong>2.构造函数不需要return</strong></p>
<p><strong>3.调用构造函数 必须使用new new构造函数在内存中创建了一个空的对象</strong></p>
<p><strong>4.必须使用this，this指向new创建的空对象</strong></p>
<p><strong>5.执行构造函数的代码后，就会给这个空对象添加属性和方法</strong></p>
<p><strong>6.new会返回创建后的对象</strong></p>
<p><strong>遍历对象</strong></p>
<p><strong>语法： for（变量 in 对象） {}</strong></p>
<p>for(var k in obj) {     console.log(k); // 遍历输出属性名     console.log(obj[k]); //遍历输出属性值 } </p>
<p>注意:</p>
<p>1.k可以改为任意变量名，一般用k</p>
<p>2.k为数组</p>
<p><strong>3.也可以用于数组！！！</strong></p>
<p>4.该方法会<strong>枚举所有可枚举的属性，包括自有属性和继承属性</strong>（除非利用Object.defineProperty（）人为设定为不可枚举）</p>
<p><strong>5.许多预定义内部属性和方法，包括所有的内部方法都是不可枚举的</strong></p>
<p><strong>删除属性</strong></p>
<p><strong>语法：delete 属性</strong></p>
<p>删除运算数指定的<strong>对象的属性、数组元素或变量</strong>（严格模式不可删除）。返回布尔值</p>
<p>内部核心属性、客户端属性、用var语句声明的用户定义变量都不能删除</p>
<p>var obj = {     num:10,     age:20 } delete obj.num; console.log(obj);// num消失 </p>
<p><strong>注意：</strong></p>
<p>delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性</p>
<p><strong>检查属性的存在性</strong></p>
<p>1.检测对象或数组中是否有某个属性，返回布尔值</p>
<p><strong>语法：属性名 in 对象或数组</strong></p>
<p>var obj = {     num:10,     age:20 } console.log("num" in obj);//true </p>
<p><strong>注意：**</strong>该方法可以检测所有的属性方法，包括自定义类内置的和原型链上的以及原始类的属性方法**</p>
<p>2.只能检测对象的自有属性</p>
<p><strong>语法：对象.hasOwnProperty(属性名） 返回布尔值</strong></p>
<p>function Star() {         this.name = 1     }     Star.prototype.age =12;     Object.prototype.male = 'man';     var ldh = new Star();      console.log(ldh.hasOwnProperty('name'));//true     console.log(ldh.hasOwnProperty('male'));//false </p>
<p><strong>确定对象类型</strong></p>
<p><strong>1.typeof：用于区分number、string、boolean、undefined、function、symbol这些基本类型</strong></p>
<p><strong>2.instanceof：一旦确定了一个值不是基本类型或函数，就可以用instanceof来确定是哪种内建对象的实例,对于基本类型包装对象无效</strong></p>
<p><strong>3.Object.toString（）：返回的是[object class]，class是对象的内部类型，通常与该对象的构造函数名字对应。如Array,Function,Date,Math</strong></p>
<p><strong>4.constructor:返回原型对象所属的类，返回的是整个构造函数</strong></p>
<p><strong>序列化对象（将对象的状态转为字符串或将字符串还原为对象）</strong></p>
<p><strong>利用JSON.stringify（）和JSON.parse()来序列化和还原对象</strong></p>
<p><strong>JSON（JavaScript Object Notation）:JavaScript对象表示法</strong></p>
<p><strong>内置对象</strong> </p>
<p>常用 Math Date Array String等</p>
<p><strong>1.数学对象</strong></p>
<p>不是构造函数，无需用new调用。而是可以直接调用其类属性及类方法</p>
<p><strong>调用属性 如 输出pi值 Math.PI</strong></p>
<p>console.log(Math.PI); // 3.14.... </p>
<p><strong>调用方法 如 取最大值 Math.max</strong></p>
<p>console.log(Math.max(1,2,3)); // 3 </p>
<p>如果有一个或一个以上的值为非整数型，则返回NaN</p>
<p>如果没有赋值，则返回-Infinity</p>
<p><strong>求开根号 Math.sqrt(x)  返回x的开根号值</strong></p>
<p>var x = Math.sqrt(81); console.log(x); </p>
<p><strong>求绝对值 Math.abs</strong>  </p>
<p>console.log(Math.abs(1)); //1 console.log(Math.abs(-1)); // 1 console.log(Math.abs('-1'));  // 1 有隐式转换 可以直接字符串转为数字型 console.log(Math.abs('哈哈'); // NaN </p>
<p><strong>三个取整方法</strong></p>
<p><strong>1.Math.floor（） 向下取整，往最小了取值,不会四舍五入</strong></p>
<p>console.log(Math.floor(1.1)); // 1 console.log(Math.floor(1.9)); // 1 </p>
<p><strong>2.Math.ceil（）  往上取整，往最大了取，不会四舍五入</strong></p>
<p>console.log(Math.ceil(1.9)); // 2 console.log(Math.ceil(1.1)); // 2 </p>
<p><strong>3.Math.round() 四舍五入取整**</strong>（其他都是四舍五入，只有5是往大了取）**</p>
<p>console.log(Math.round(1.1)); // 1 console.log(Math.round(1.9)); // 2 console.log(Math.round(-1.5)); // -1 </p>
<p><strong>随机数</strong></p>
<p><strong>Math.random() 返回一个随机的0到1之间的小数（不包含0和1）且不跟参数</strong></p>
<p>得到两个整数之间的随机整数：</p>
<p>function getRandom(min,max) {     console.log(Math.floor(Math.random()*(max-min+1)+min));   } </p>
<p><strong>2.日期对象</strong></p>
<p><strong>Date() 日期对象 是一个构造函数 必须使用new来调用创建自己的日期对象</strong></p>
<p>使用方法</p>
<p>var date = new Date(); console.log(date); </p>
<p>参数写法</p>
<p><strong>无参数则返回当前系统时间</strong></p>
<p>数字型：2019，10，01    字符型：’2019-10-1 8：8：8‘</p>
<p>var date1 = new Date(2019,10,1); or var date2 = new Date('2019-10-1 8:8:8'); </p>
<p>具体方法</p>
<p><strong>返回当前年份</strong></p>
<p><strong>对象名.getFullYear()</strong> </p>
<p><strong>返回当前月份</strong></p>
<p><strong>对象名.getMonth()+1</strong></p>
<p><strong>注意：是从0开始到11 所以应该+1 否则得到的月份少一个月</strong></p>
<p><strong>返回当前号数</strong></p>
<p><strong>对象名.getDate()</strong> </p>
<p><strong>返回周几</strong></p>
<p><strong>对象名.getDay()</strong> </p>
<p><strong>注意：是从0（即星期日）开始到6（星期六）</strong></p>
<p><strong>返回小时</strong></p>
<p><strong>对象名.getHours();</strong></p>
<p><strong>返回分钟</strong></p>
<p><strong>对象名.getMinutes()</strong></p>
<p><strong>返回秒钟</strong></p>
<p><strong>对象名.getSeconds()</strong></p>
<p><strong>返回自1970年来的总毫秒数</strong></p>
<p><strong>1.对象名.getvalueOf() 或者 对象名.getTime()</strong></p>
<p><strong>2.var 对象名 = +new Date();</strong></p>
<p><strong>3.console.log(Date.now())   低版本浏览器不支持</strong></p>
<p><strong>3.数组对象</strong></p>
<p>创建方式</p>
<p><strong>1.利用字面量</strong></p>
<p>var arr = [1,2,3]; console.log(arr[0]); </p>
<p><strong>2.利用new Array()</strong></p>
<p>var arr1 = new Array(); //空数组 var arr2 = new Array(2); //长度为2的空数组 var arr3 = new Array(2,3);// 内容为2和3的数组 </p>
<p><strong>检测变量是否为数组的方法</strong></p>
<p><strong>1.利用 instanceof</strong></p>
<p><strong>变量名 instanceof Array</strong> </p>
<p>返回的是布尔值</p>
<p>var arr = []; var obj = {}; console.log(arr instanceof Array); // 返回true console.log(arr instanceof Array); // 返回false </p>
<p>注：亦可用来判断是否为对象类型 ：变量名 instanceof Object</p>
<p><strong>2.利用Array内置对象的行为</strong></p>
<p><strong>Array.isArray（变量）</strong></p>
<p>返回的也是布尔值</p>
<p>Array.isArray([1,2,3]); // TRUE Array.isArray(1,2,3); // FALSE </p>
<p><strong>给数组添加元素的方法</strong></p>
<p><strong>1.末尾添加</strong></p>
<p>数组名.push（元素1，元素2，...）； </p>
<p>var arr = [1,2,3]; arr.push(1,'dada'); // 返回结果是数组长度 </p>
<p><strong>2.头部添加</strong></p>
<p>数组名.unshift（元素1，元素2，...）;</p>
<p>var arr = [1,2,3]; arr.unshift('red','purple');  // 返回结果是数组长度 </p>
<p><strong>3.尾部删除</strong></p>
<p>数组名.pop（）</p>
<p>arr.pop(); //pop没有参数 返回删除的元素 一次只能删除一个元素 </p>
<p><strong>4.头部删除</strong></p>
<p>数组名.shift()</p>
<p>arr.shift() //没有参数 返回删除的元素 一次只能删除一个 </p>
<p>总结</p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C626a3cafae634dc899997633d8cc7dbd%5Cd0925c276df34b83870456b2f29fc12e.jpg" alt="img"></p>
<p><strong>数组排序的方法</strong></p>
<p><strong>1.数组翻转</strong></p>
<p><strong>数组名.reverse（）；</strong></p>
<p>var arr = [1,2,3]; arr.reverse(); console.log(arr); </p>
<p><strong>2.数组排序</strong></p>
<p><strong>数组名.sort（）； 只对一位数起效，多位数会出错</strong></p>
<p><strong>数组名.sort(function(a,b) { a - b})  升序排序</strong></p>
<p><strong>数组名.sort(function(a,b) { b - a})  降序排序</strong></p>
<p>var arr1 = [3,4,8,12]; arr1.sort(function(a,b) {     // return a - b;  升序排列     return b - a; }); </p>
<p><strong>获取数组元素索引方式</strong></p>
<p><strong>1.变量名.indexOf(元素值);</strong></p>
<p>var arr = ['red','green','pink','blue'] console.log(arr.indexOf('blue')); </p>
<p>注：返回第一个满足条件的索引号 </p>
<p><strong>如果该数组里找不到元素，则返回-1</strong></p>
<p><strong>2.变量名.lastIndexOf（元素值）；</strong></p>
<p>注：从末尾开始找 返回正序的索引号</p>
<p>console.log(arr.lastIndexOf('blue')) </p>
<p>注：只能用于数组，不能用于节点</p>
<p><strong>数组转为字符串</strong></p>
<p><strong>1.变量名.toString（）；</strong></p>
<p>var arr = [1,2,3]; console.log(arr.toString()); </p>
<p><strong>2.变量名.join();</strong></p>
<p>把数组所有元素转换成字符串，再把它们连接起来。可以指定一个可选的字符串来分隔结果字符串中的元素。默认为逗号分隔</p>
<p>var arr1 = ['green','blue','pink']; console.log(arr1.join());//green,blue,pink console.log(arr1.join(''));//greenbluepink </p>
<p><strong>数组的截取删除连接</strong></p>
<p><strong>数组链接</strong></p>
<p>数组名1.concat（数组名2）；</p>
<p>数组名1.concat（元素值,元素值,...）；</p>
<p>var num1 = [1,2,3]; var num2 = ['a','b','c']; console.log(num1.concat(num2)); console.log(num1.concat(num2,1,[2,3])); </p>
<p><strong>数组删除插入（改变原数组,返回被删除的值）</strong></p>
<p><strong>数组名.splice(起始位置，删除个数，添加元素）</strong></p>
<p>var num3 = ['ha','xi','hei','he']; var num4 = num3.splice(1,0,'en'); // 在第1位后插入'en' var num5 = num3.splice(1,1); //第1位开始删除一位  console.log(num5); // 'xi' var num6 = num3.splice(2,1,'en','o'); console.log(num3);// 'ha' 'xi' 'en' 'o' 'he' </p>
<p><strong>数组截取(不会改变原数组，只是截取出来作为新数组）</strong></p>
<p><strong>数组名.slice(开始位置（包含），结束位置（不包含））；</strong></p>
<p>var num7 = [1,2,3,4,5,6]; console.log(num7.slice(2)); // 3,4,5,6 console.log(num7.slice(1,3));// 2,3 // num7依旧为1，2，3，4，5，6 </p>
<p><strong>4.字符串对象</strong></p>
<p><strong>基本包装类型：js不仅支持数字字符串和布尔值这些数据类型，还支持Number、String、Boolean类，这些类是其对应基本数据类型的包装。不仅具有和基本类型一样的值，还定义了用来运算数据的属性和方法</strong></p>
<p>过程：</p>
<p>（1）字符串值内部创建一个String包装对象</p>
<p>var temp = new String(字符串值)</p>
<p>(2)代替原始的字符串值</p>
<p>变量名 = temp；</p>
<p>（3）销毁temp</p>
<p>temp=null;</p>
<p><strong>字符串不可变性：字符串赋值后重新赋值需要重新创建内存空间，原先的内存及其值不变。所以不要大量拼接字符串，即字符串的值无法修改</strong></p>
<p><strong>字符串所有方法，都不会修改字符串本身内容，而是创建新的字符串</strong></p>
<p><strong>实例方法</strong></p>
<p><strong>根据字符串返回索引值</strong></p>
<p><strong>字符串名.indexOf（具体某个字符串，开始位置（默认无））;</strong></p>
<p>var str ='改革春风吹满地,春天来了'; console.log(str.indexOf('春')); // 返回2 console.log(str.indexOf('春',3)); // 返回8 </p>
<p><strong>根据索引值返回字符串</strong></p>
<p><strong>1.字符串变量名.charAt(索引值）</strong></p>
<p>var str='1234'; var a = str.charAt(1); </p>
<p><strong>2.字符串变量名.charCodeAt(索引值） 返回对应位置字符的ASCII码 用于判断用户按键</strong></p>
<p>console.log(str.charCodeAt(0)); </p>
<p><strong>3.变量名[索引值]</strong></p>
<p>console.log(str[1]); </p>
<p><strong>字符串连接</strong></p>
<p>字符串1.concat（字符串2）；</p>
<p>字符串1.concat（字符,字符,...）；</p>
<p>一般用加号</p>
<p><strong>字符串截取</strong></p>
<p><strong>字符串.substr（截取起始位置，截取的字符数） 不改变原字符串</strong></p>
<p>var str = '改革春风吹满地'; console.log(str.substr(2,2)); </p>
<p><strong>字符串替代</strong></p>
<p><strong>字符串.replace（‘被替换的字符’，‘替换为的字符’）</strong></p>
<p>返回的是新修改后的字符串，原字符不变</p>
<p>var str='andy'; console.log(str.replace('y','d')); // 有一个字符串'abcoefoxyozzopp' 要求把所有o替换为* var str1='abcoefoxyozzopp'; for(i=0;i<str1.length;i++) {     str1 = str1.replace('o','*'); } </p>
<p><strong>字符串转为数组</strong></p>
<p><strong>字符串.split（‘分隔符’）</strong></p>
<p>原字符串用什么分割，就用什么做分隔符 不改变原字符串</p>
<p>var str1 = 'red,pink,blue'; console.log(str1.split(',')); var str3 = 'red&pink&blue'; console.log(str3.split('&')); </p>
<p><strong>字符串大小写转换</strong></p>
<p><strong>字符串.toUpperCase（） 将字符串转为大写</strong></p>
<p><strong>字符串.toLowerCase（） 将字符串转为大写</strong></p>
<p><strong>注：字符串大小比较是按对应字母一个一个比</strong></p>
<p><strong>去除字符串左右的空格</strong></p>
<p><strong>字符串.trim()</strong></p>
<p><strong>可用来去除表单只填入空格时造成的bug</strong></p>
<p><strong>判断字符串开头结尾</strong></p>
<p><strong>字符串.startsWith('xxx');  判断str字符串是否以xxx开头</strong></p>
<p><strong>字符串.endsWith('xxx');  判断str字符串是否以xxx结尾</strong></p>
<p>let str = 'hello myworld'; // startsWith 判断字符串是否以某字符串开头 返回布尔值 console.log(str.startsWith('he'));//true // endsWith 判断字符串是否以某字符串结尾 返回布尔值 console.log(str.endsWith('rld'));//true </p>
<p><strong>重复某个字符串</strong></p>
<p><strong>字符串.repeat(n) 将字符串str重复n次，返回新的，不改变旧的</strong></p>
<p>let str = 'x'.repeat(5); console.log(str); str1 = str.repeat(2); console.log(str1); </p>
<p><strong>类方法</strong></p>
<p><strong>根据ASCII码返回字符串</strong></p>
<p><strong>String.fromCharCode(***</strong>num1<strong>***,</strong> <strong><em>...**</em></strong>,** <strong><em>numN**</em></strong>)**</p>
<p>console.log(String.fromCharCode(78));//N </p>
<p><strong>简单和复杂数据类型</strong></p>
<p><strong>简单数据类型（基本数据类型或值类型）：存储时变量中存放的是值本身，因此叫值类型，如number、boolean、undefined、null。都具有固定的内存大小</strong></p>
<p><strong>其中null的返回类型是Object，因此一般可先用来定义对象</strong></p>
<p>var timer = null; console.log(typeof null); //结果为object </p>
<p>如果有个变量打算存储为对象但没想好放什么属性和行为，那么就可以先设置为null类型</p>
<p><strong>复杂数据类型（引用类型）：变量中存储的仅仅是地址，如对象及其特殊类型数组和函数</strong></p>
<p><strong>其中字符串不能很好地适合基本类型和引用类型的二分法。因为字符串不是对象，被当做基本类型，而字符串又有任意的长度，所以也可以被认为是引用类型。字符串是通过传值来比较</strong></p>
<p><strong>堆和栈</strong></p>
<p><strong>栈：存放简单数据类型，由操作系统自动分配释放存放函数的参数值、局部变量的值等。简单数据类型直接查找存放在栈中的变量的值（简单数据>栈>变量>值）</strong></p>
<p><strong>堆：存放复杂数据类型，一般由程序员分配释放。复杂数据类型通过存放在栈中的变量中的地址找到存放在堆中的值（复杂数据>栈>变量>地址>堆>值）</strong></p>
<p><strong>简单数据类型的传参（传值）</strong></p>
<p><strong>函数的形参可以看做一个变量，当把一个变量传给函数形参就等于把变量的值复制一份给形参。所以对函数内变量的修改不会影响外部变量</strong></p>
<p><strong>复杂数据类型的传参（传址）</strong></p>
<p><strong>函数的形参可以看做一个变量，当把一个变量传给函数形参就等于把变量存放的堆地址复制一份给形参，即形参和实参保存的是同个堆地址，所以操作的是同一个对象。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>js之BOMDOM</title>
    <url>/2020/03/12/js%E4%B9%8BBOMDOM/</url>
    <content><![CDATA[<p>DOM:文档对象模型（document object model）</p>
<p>BOM：浏览器对象模型</p>
<p>API（application programming interafce，应用程序编程接口）：是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节</p>
<p>Web API:浏览器提供的一套操作浏览器功能和页面元素的API</p>
<p><strong>可以将Web浏览器当做简单操作系统，就可以web应用定义为JavaScript访问更多浏览器提供的高级服务的Web页面</strong></p>
<p><strong>文档中的javaScript的角色定位：增强用户浏览体验，使信息的获取和传递更容易。而不是降低网页的可访问性。</strong></p>
<p><strong>DOM：</strong>文档对象模型（document object model），处理HTML或者XML的标准编程接口，通过DOM可以改变网页的内容、结构和样式</p>
<p><strong>文档：一个**</strong>页面就是一个文档<strong><strong>，DOM中用</strong></strong>document<strong>**表示</strong></p>
<p><strong>元素：页面中**</strong>所有标签都是元素<strong><strong>，DOM用</strong></strong>element<strong>**表示</strong></p>
<p><strong>节点：网页中所有内容都是节点（标签属性文本注释等），DOM中用**</strong>node<strong>**表示</strong></p>
<p>DOM把以上内容都看作是对象</p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cf19ca06354dc4a05b6a61f1311192697%5C9e44e8cde88e40ac8849b96965c32c3b.jpg" alt="img"></p>
<p><strong>获取页面元素</strong></p>
<p>1.根据ID获取</p>
<p>2.根据标签名获取</p>
<p>3.根据h5新增属性获取</p>
<p>4.特殊元素获取</p>
<p>5.根据window属性获取（不推荐）</p>
<p>6.利用HTMLCollection（HTML集合）快捷获取</p>
<p><strong>1.根据ID获取</strong></p>
<p><strong>document.getElementById(ID名）</strong></p>
<body>     <div id="time">2019-9-9</div>     <script type="text/javascript">         var timer = document.getElementById('time');         console.log(timer);         console.log(typeof timer);         console.dir(timer);     </script> </body> 

<p><strong>注意点</strong></p>
<p><strong>1.因为文档页面从上往下加载，所以先得有标签，script写到标签下面</strong></p>
<p><strong>2.参数id是大小写敏感的字符串 一定要加引号</strong></p>
<p><strong>3.返回的是一个文档对象object（即有众多属性和方法）</strong></p>
<p><strong>4.console.dir  打印对象且能更好查看里面的属性和方法</strong></p>
<p><strong>2.根据标签名获取</strong></p>
<p><strong>document.getElementsByTagName(标签名）</strong></p>
<p><strong>父元素.getElementsByTagName（标签名）</strong></p>
<p>var lis = document.getElementsByTagName(‘li’); console.log(lis); console.log(lis[2]); for(var i = 0;i&lt; lis.length;i++ ) {     console.log(lis[i]); }  var ol = document.getElementsByTagName(‘ol’); console.log(ol[0].getElementsByTagName(‘li’));  var ol = document.getElementById(‘ol’); console.log(ol.getElementsByTagName(‘li’)); </p>
<p>注意：</p>
<p>1.返回的值是伪数组，即所有相应标签的集合，即以伪数组的形式存储（无论有多少个，即使是0个），单个元素仍为对象，得到的元素是动态的</p>
<p>2.可用遍历方式打印里面具体的元素对象</p>
<p>3.通过父元素获取标签时，父元素必须是具体的单个对象，如果父元素是通过标签名获取，则获取其子元素时应加上索引号。也可以直接通过ID获取不加索引号</p>
<p><strong>3.h5新增，返回的是NodeList对象</strong></p>
<p><strong>document.getElementsByClassName（标签名）</strong></p>
<p>var boxs = document.getElementsByClassName(‘box’);         console.log(boxs); </p>
<p>注意</p>
<p>1.返回的依旧是伪数组形式</p>
<p><strong>document.querySelector（选择器） 如（#id，.类名，标签名）</strong></p>
<p>返回指定选择器的第一个元素</p>
<p>var firstbox = document.querySelector(‘.box’); console.log(firstbox); var nav = document.querySelector(‘#nav’); console.log(nav); var one = document.querySelector(‘li’); console.log(one); </p>
<p>注意：永远只会返回一个元素对象</p>
<p><strong>document.querySelectorAll(选择器)</strong></p>
<p>返回选定选择器的所有元素集合</p>
<p>var allbox  = document.querySelectorAll(‘.box’) ; console.log(allbox); var lis = document.querySelectorAll(‘li’); console.log(lis[1]); </p>
<p>注意：返回的是伪数组形式（无论对象元素数量多少）</p>
<p><strong>4.获取特殊元素</strong></p>
<p><strong>1.获取body元素</strong></p>
<p><strong>document.body</strong></p>
<p>var bodyEle = document.body; console.log(bodyEle); </p>
<p><strong>2.获取html元素</strong></p>
<p><strong>document.documenElement</strong></p>
<p>var htmlEle = document.documentElement; console.log(htmlEle); </p>
<p><strong>3.获取head元素</strong></p>
<p><strong>document.head</strong></p>
<p>console.log(document.head); </p>
<p><strong>5.根据window属性获取赋予id、name属性的html标签（**</strong>不推荐<strong>**）</strong></p>
<p>如果HTML文档中用id属性为元素命名，并且<strong>Window对象没有该名字的属性</strong>，那么Window对象会创建一个同名属性，该属性指向以该名字命名id属性的html元素</p>
<body>
    <div id="one"></div>
    <script type="text/javascript">
        console.log(window.one);//<div id="one"></div>
    </script>
</body>



<p>对于a、iframe、img、form等标签来说，如果有name属性，那么也会有与上面同样的表现。如果有多个相同name属性，则具有该名称的隐式全局变量会引用一个伪数组对象</p>
<img src="" alt="" name="ii">
    <img src="" alt="" name="ii">
    <script type="text/javascript">
        console.log(window.ii);//HTMLCollection(2) [img, img, ii: img]
    </script>



<p><strong>6.利用HTMLCollection（HTML集合）快捷获取，返回的是HTMLCollection对象</strong></p>
<p><strong>HTMLDocument</strong>中定义了一些属性，如images、forms、links可以快速获取img、form、a等标签</p>
<img src="" alt="">
<img src="" alt="">
    <script type="text/javascript">
        console.log(document.images);//HTMLCollection(2) [img, img]
    </script>



<p><strong>事件概述：可以被javascript侦测到的行为</strong></p>
<p>事件三要素</p>
<p>1.事件源（可以通过获取对象方式获取）</p>
<p>2.事件类型（设置事件的触发方式）</p>
<p>3.事件处理程序（通过函数赋值方式完成）</p>
<p>var btn = document.getElementById(‘btn’); btn.onclick = function () {     alert(‘点秋香’); } </p>
<p>注意：第一句为获取事件源 .onclick为事件类型 function及后面为事件处理程序</p>
<p><strong>事件执行三步骤：</strong></p>
<p><strong>1.获取事件源</strong></p>
<p><strong>2.绑定事件</strong></p>
<p><strong>3.添加事件处理程序</strong></p>
<p><strong>常见鼠标事件</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C4ecea1eb65614c038665f07ef890d9ed%5C05360a001dd542bb8ac2b9a88b7e4b48.jpg" alt="img"></p>
<p><strong>ondblclick 双击事件</strong></p>
<p><strong>改变元素内容（不适用于表单）</strong></p>
<p><strong>1**</strong>.innerText：不识别html标签，非标准，会去除空格和换行**</p>
<p><strong>2.**</strong>innerHTML：识别html标签，W3C标准，不会去除空格和换行**</p>
<p><strong>3.**</strong>insertAdjacentHTML（位置,目标元素）  可以实现在目标元素中特定位置插入字符串**</p>
<p>注：两个属性可读写，可以获取元素内容</p>
<p>var p = document.querySelector(‘p’); console.log(p.innerText); console.log(p.innerHTML); </p>
<p><strong>常用元素属性修改：src、href、title、alt、id</strong></p>
<p><strong>改变表单元素内容</strong></p>
<p><strong>input.value</strong></p>
<p>var btn = document.querySelector(‘button’); var input = document.querySelector(‘input’); btn.onclick = function() {     input.value = ‘haha’;     this.disabled = true; } </p>
<p>注意：</p>
<p><strong>1.表单元素更改只能用value</strong></p>
<p><strong>2.**</strong>disabled实现表单禁用**</p>
<p><strong>3.函数中的this指向函数的调用者</strong></p>
<p><strong>4.这些都是属性不是样式，不用写style</strong></p>
<p>img.src 等等</p>
<p><strong>可以通过修改表单type类型实现密码明文密文的转换</strong></p>
<p><strong>改变元素对象样式</strong></p>
<p><strong>1.element.style.样式 = ‘属性值’；  一般用于样式较少或功能简单的情况下使用</strong></p>
<p>var div = document.querySelector(‘div’); div.onclick = function() {     // div.style 里面的样式用驼峰命名法     this.style.backgroundColor = ‘purple’;     this.style.width = ‘400px’;     // 修改后的样式为行内样式 权重比较高 } </p>
<p>注意：</p>
<p>1.利用js style修改的样式都得用驼峰命名法 如backgoroundColor、fontSize</p>
<p>2.js修改后的样式都以行内样式生成，权重高</p>
<p>3.样式的属性都是在style中，所以需要些xx.style.属性</p>
<p><strong>获得失去焦点</strong></p>
<p><strong>获得焦点（即点击输入框时）</strong></p>
<p><strong>变量名.onfocus</strong></p>
<p><strong>失去焦点（取消点击输入框时）</strong></p>
<p><strong>变量名.onblur</strong></p>
<p><strong>2.通过element.className增加类名从而修改样式（适用于样式较多，功能复杂的情况使用）</strong></p>
<p>即在css先定义好新的样式在新的类名中，再在js中对目标元素设置事件利用className更换新的类</p>
<p>​        .change {<br>​            background-color: purple;<br>​            color: #fff;<br>​            font-size: 25px;<br>​            margin-top: 100px;<br>​        }<br>​    </style></p>
</head>
<body>
    <div>文本</div>
    <script type="text/javascript">
        var test = document.querySelector('div');
        test.onclick = function() {
            //将当前类名改为change 从而改变样式
            this.className = 'change';
        }
    </script>

<p>注意：className会完全覆盖先前的类名</p>
<p>若想同时保留新旧类名 则可以在添加时新旧一起写</p>
<p>this.className = ‘first change’;      </p>
<p><strong>排他思想</strong></p>
<p>如果有同一组元素，想要某一个元素实现某种样式，那么就需要排他思想</p>
<p><strong>1.先排除其他人的样式</strong></p>
<p><strong>2.再设置自己的样式</strong></p>
<p>for( var i = 0;i &lt; btns.length;i++) {     btns[i].onclick = function() {         // 想把所有按钮颜色去掉         // 再修改当前颜色         for(var i = 0;i &lt; btns.length;i ++) {             btns[i].style.backgroundColor = ‘’;         }         this.style.backgroundColor = ‘pink’;     } } </p>
<p><strong>获取自定义属性</strong></p>
<p>获取属性一般有两种</p>
<p>1.element.属性 </p>
<p><strong>2.element.getAttribute(‘属性’）</strong></p>
<p>var div = document.querySelector(‘div’); console.log(div.getAttribute(‘index’)); </p>
<p>区别</p>
<p>1.第一种用于获取元素本身自带的属性</p>
<p>2.第二种一般用于获取通过setAttribute自定义的属性（即程序员自己定义的属性），通过setAttribute设置的属性只能用第二种获取</p>
<p>设置属性值的方法</p>
<p>1.element.属性 = ‘属性值’；</p>
<p><strong>2.element.setAttribute（‘属性’，’值‘）；</strong></p>
<p>var div = document.querySelector(‘div’); div.setAttribute(‘index’,’2’); </p>
<p>自定义属性也可以通过第一种设置，但只能用xxx.属性名获取</p>
<p>移除属性的方法</p>
<p><strong>element.removeAttribute(‘属性’);</strong></p>
<p>div.removeAttribute(‘index’); </p>
<p><strong>h5新增自定义属性方法</strong></p>
<p><strong>data-属性名</strong></p>
<p><strong>data-开头的属性必定是自定义属性</strong></p>
<div data-time="2" data-list-name='andy'></div>

<p>获取data自定义属性方法有两种：</p>
<p><strong>1.element.getAttribute(‘data-属性名’)</strong></p>
<p>console.log(div.getAttribute(‘data-time’)); div.setAttribute(‘data-index’,2); //设置属性值 </p>
<p><strong>2.element.dataset.data后面的属性名 或 element.dataset[‘data后面的属性名’]</strong></p>
<p>console.log(div.dataset.index); console.log(div.dataset[‘index’]); console.log(div.dataset.listName); console.log(div.dataset[‘listName’]); </p>
<p>特别注意：对于data-后面还有横杠的命名的属性值在利用dataset获取时应该用驼峰命名法，getAttribute则不用</p>
<p><strong>节点：页面中所有内容都是节点，用node表示</strong></p>
<p><strong>节点的三个属性：1.节点类型（nodeType ） 2.节点名称（nodeName） 3.节点值（nodeValue）</strong></p>
<p><strong>元素节点nodeType=1</strong></p>
<p><strong>属性节点nodeType=2</strong></p>
<p><strong>文本节点nodeType=3</strong></p>
<p><strong>操作的主要是元素节点</strong></p>
<p>节点可以划分为不同的层级关系，常见的是父子兄层级节点</p>
<p><strong>父子节点操作</strong></p>
<p><strong>获取父节点</strong></p>
<p><strong>node.parentNode(获得最近的父节点，如果找不到则返回NULL）</strong></p>
<p>var erweima = document.querySelector(‘.erweima’); console.log(erweima.parentNode); </p>
<p><strong>获取子节点</strong></p>
<p>node.childNodes 返回的是元素节点以及文本节点，</p>
<p><strong>node.children 只返回元素节点 获得的是伪数组</strong></p>
<p>console.log(ul.children); </p>
<p>获取第一个和最后一个子节点</p>
<p>node.firstChild</p>
<p>node.lastChild</p>
<p>以上都返回包括文本节点在内的所有节点 不常用</p>
<p>node.firstElementChild</p>
<p>node.lastElementChild</p>
<p>只返回元素节点，但是有兼容性问题</p>
<p>实际写法</p>
<p><strong>node.children[0] 返回第一个</strong></p>
<p><strong>node.children[node.children.length-1] 返回最后一个</strong></p>
<p>console.log(ol.children[0]); console.log(ol.children[ol.children.length-1]); </p>
<p><strong>获取兄弟节点</strong></p>
<p>node.nextSibling 下一个兄弟节点    </p>
<p>node.previousSibling 下一个兄弟节点</p>
<p>以上获取的都是包含文本节点元素节点的兄弟节点 </p>
<p>var div = document.querySelector(‘div’); console.log(div.nextSibling); console.log(div.previousSibling); </p>
<p><strong>node.nextElementSibling        下一个兄弟元素节点</strong></p>
<p><strong>node.previousElementSibling        上一个兄弟元素节点</strong></p>
<p>以上都只获取为元素节点的兄弟节点 <strong>有兼容性问题</strong></p>
<p>console.log(div.nextElementSibling); console.log(div.previousElementSibling); </p>
<p>解决方案：自己利用节点类型nodeType封装一个函数</p>
<p><strong>创建节点</strong></p>
<p><strong>document.createElement(元素名称）</strong></p>
<p>var li = document.createElement(‘li’); </p>
<p><strong>添加节点（两种方法)</strong></p>
<p><strong>1.node.appendChild（child);       ndoe为父节点 child为新创建的节点</strong> <strong>添加到父级最后面</strong> </p>
<p>var ul = document.querySelector(‘ul’); ul.appendChild(li); </p>
<p><strong>2.node.insertBefore(child,指定位置）  即将新创建的child节点添加到指定元素之前</strong></p>
<p>var lili = document.createElement(‘li’); ul.insertBefore(lili,ul.children[0]); </p>
<p><strong>删除节点</strong></p>
<p><strong>node.removeChild()</strong></p>
<p>ul.removeChild(ul.children[0]); </p>
<p><strong>克隆节点</strong></p>
<p><strong>node.cloneNode()</strong></p>
<p>括号里如果为空或者是false则只复制node本身不复制里面的子节点</p>
<p>如果为true则复制节点本身及其所有子节点</p>
<p>var lili = ul.children[0].cloneNode(); /li var lili = ul.children[0].cloneNode(true); //<li>1</li> </p>
<p><strong>附：阻止链接跳转可以对a的href设置为javascript：；</strong></p>
<p><strong>总结</strong></p>
<p><strong>获取父节点 node.parentNode</strong></p>
<p><strong>获取子节点 node.children</strong></p>
<p><strong>获取兄弟节点node.nextElementSiibling  node.previousElementSibling（兼容性差）</strong></p>
<p><strong>创建节点 document.createElement(节点类型）</strong></p>
<p><strong>添加节点 尾部添加 node.appendChild()  某个元素之前添加 node.insertBefore(child,指定元素)</strong></p>
<p><strong>删除节点 node.removeChild() node为删除目标元素的父元素</strong></p>
<p><strong>复制节点 node.cloneNode()</strong> </p>
<p><strong>三种动态创建元素区别</strong></p>
<p><strong>1.document.write()</strong> </p>
<p><strong>2.element.innerHTML（）  配合字符串使用</strong></p>
<p><strong>3.document.createElement（）配合append、insertbefore使用</strong></p>
<p><strong>注意</strong></p>
<p><strong>1.document.wirte如果是文档流执行完毕写入，会导致页面全部重绘 没啥乱用</strong></p>
<p><strong>2.innerHTML 创建多个元素效率更高 前提是不要拼接字符串 而是通过先创建数组再将数组转换为字符串赋予对象的形式</strong></p>
<p><strong>3.createElement（） 创建多个元素效率相对innerHTML的数组赋值方式较低，但是结构更清晰</strong></p>
<p><strong>总结：不同浏览器下，采取数组赋值的innerHTML效率比creatElement高</strong></p>
<p><strong>事件高级</strong></p>
<p><strong>注册事件的两种方法（传统方式和监听注册方式）</strong></p>
<p><strong>1.传统方式（最简单的方式，即将函数赋值给目标对象的事件属性，属性名字都以”on”开头）</strong></p>
<p><strong>变量名.onclick = funciton（）{}</strong></p>
<p>特点：唯一性，即同个元素同个事件只能设置一个处理函数，如果重复注册则以最新一个为准</p>
<p>var btns = document.querySelectorAll(‘button’);         btns[0].onclick = function() {             alert(‘HI’);         } </p>
<p><strong>2.监听注册方式（推荐 为W3C标准 IE9之前不支持）</strong></p>
<p><strong>变量名.addEventListener(‘事件触发方式’,处理函数,事件流执行顺序参数（布尔值））</strong></p>
<p>特点：用一个元素同一个事件可以注册多个监听器，按注册顺序依次执行</p>
<p><strong>注意：事件触发方式不能带on，且因为是字符串必须加引号  处理函数可以写函数名也可以写整个函数</strong></p>
<p>btns[1].addEventListener(‘click’,function() {             alert(‘22’);         }) </p>
<p><strong>3.attachEvent方式（ie9之前支持 了解即可）</strong></p>
<p>变量名.attachEvent(事件类型（带on），时间处理函数）</p>
<p>btns[2].attachEvent(‘onclick’,function() {             alert(‘11’);         }); </p>
<p><strong>在元素上写事件和addEventListent()的区别</strong></p>
<p><strong>1.onclick添加事件不能绑定多个事件，后面绑定的会覆盖前面的。而addEventListener能添加多个事件绑定，按顺序执行。</strong></p>
<p><strong>2.addEventListener方式，不支持低版本的IE。（attachEvent 支持IE）。</strong></p>
<p><strong>3.普通方式绑定事件后，不可以取消。addEventListener绑定后则可以用 removeEventListener 取消。</strong></p>
<p><strong>4.addEventListener 是W3C DOM 规范中提供的注册事件监听器的方法。</strong></p>
<p><strong>5.对于传统事件注册记得加on,如onclick，onkeydown等</strong></p>
<p><strong>删除事件</strong></p>
<p><strong>1.对于传统方式注册的事件</strong></p>
<p><strong>变量名.事件类型 = null</strong></p>
<p>var divs = document.querySelectorAll(‘div’);         divs[0].onclick = function() {             alert(‘11’);             divs[0].onclick = null;         } </p>
<p><strong>2.对于监听事件注册的事件</strong></p>
<p><strong>变量名.removeEventListener(删除的事件类型，删除的函数）</strong></p>
<p>​    divs[1].addEventListener(‘click’,fn)         function fn() {             alert(‘22’);             divs[1].removeEventListener(‘click’,fn);         } </p>
<p>3.对于attachEvent注册的事件（了解）</p>
<p>变量名.detachEvent(删除的事件类型，删除的函数）</p>
<p>​    divs[2].attachEvent(‘onclick’,fn1);         function fn1() {             alert(‘33’);             divs[2].detachEvent(‘onclick’,fn1);         } </p>
<p><strong>总结：</strong></p>
<p><strong>注册事件</strong></p>
<p><strong>node.onclick</strong></p>
<p><strong>node.addEventListener(‘事件类型’，处理程序,冒泡与否值）</strong></p>
<p><strong>删除事件</strong></p>
<p><strong>node.onclick = null;</strong></p>
<p><strong>node.removeEventListener (‘事件类型’，处理程序）</strong></p>
<p><strong>事件流（页面中获取接收事件的顺序）</strong></p>
<p><strong>DOM事件流：事件发生时会在元素节点之间按照特定顺序传播</strong></p>
<p><strong>DOM事件流有三个阶段：</strong></p>
<p><strong>1.捕获阶段</strong></p>
<p><strong>事件发生时在页面中从document往下一级一级传播的过程</strong></p>
<p><strong>2.当前目标阶段</strong></p>
<p><strong>事件到达设置了该事件的元素时的阶段</strong></p>
<p><strong>3.冒泡阶段</strong></p>
<p><strong>事件接受后从事件触发节点逐级向上传播到DOM最顶层节点的过程</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Ca3c770a7e6cd4ad3bd07ce1e82579d46%5Cb7d3f32cedef4bb1ba24a0a0a829055b.jpg" alt="img"></p>
<p>注意：</p>
<p><strong>1.JS只能执行捕获或者冒泡其中一个阶段</strong></p>
<p><strong>2.onclick和attachEvent只能获得冒泡阶段</strong></p>
<p><strong>3.addEventListener第三个参数如果是true，则为捕获阶段（很少用）。如果是false(默认），则为冒泡阶段</strong></p>
]]></content>
  </entry>
  <entry>
    <title>js基础</title>
    <url>/2020/03/12/js%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong>JS概论</strong></p>
<p>HTML/CSS-标记语言</p>
<p>JS脚本语言-编程类语言</p>
<p><strong>浏览器分成两部分，渲染引擎和JS引擎</strong></p>
<p>渲染引擎:用来解析HTML与CSS，俗称内核,比如chrome的blink</p>
<p>JS引擎：JS解释器，用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的V8</p>
<p>浏览器本身并不会执行JS代码，而是通过内置JavaScript引擎来执行JS代码，JS引擎执行代码时逐行解释每一句源码（转换为机器语言二进制），然后由计算机去执行</p>
<p><strong>解释性语言：进行时立即解释执行的语言 如js</strong></p>
<p><strong>编译性语言：必须通过编译生成中间代码后才执行的语言 如java、c</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cfffb8145a3d84ffd90c259d05fae27c6%5C91c376eaf8dc4cf7ac0825ecdf328d19.jpg" alt="img"></p>
<p><strong>JS组成：ECMAscript（js语法）、DOM（页面文档对象模型）、BOM（浏览器对象模型）后两者即合称API</strong></p>
<p><strong>ECMAscript:规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准</strong></p>
<p><strong>JavaScript程序的执行</strong></p>
<p><strong>出现在<script>和</script>标记对之间的javascript语句按照它们在脚本中出现的顺序来执行。当一个文件有多个脚本的时候，脚本按照它们出现的顺序来执行（除非脚本带有defer属性）。<script>标记中的JS代码作为文档载入和解析过程的一部分来执行</strong></p>
<p><strong>JS词法结构</strong></p>
<p><strong>JS注释</strong></p>
<p><strong>单行注释：//</strong></p>
<p><strong>多行注释：/*......*/</strong></p>
<p>// 1.单行注释 ctrl+/ /<em>2.多行注释  2.多行注释  ctrl+shift+/</em>/ </p>
<p><strong>标识符、关键字、保留字、直接量</strong></p>
<p><strong>标识符：开发人员为变量、属性、函数、参数取的名字（标识符不能是关键字或保留字）</strong></p>
<p><strong>关键字：js本身已经使用了的字</strong></p>
<p><strong>保留字：为后面预留的关键字 如boolean byte char int等</strong></p>
<p><strong>字面量(直接量):程序中直接显示出来的数据值</strong></p>
<p>数字字面量：8，9，10</p>
<p>字符串字面量：“黑马程序员” “大前端”</p>
<p>布尔字面量：true false</p>
<p><strong>js命名规则</strong></p>
<p><strong>标识符命名规则</strong></p>
<p><strong>1.必须要有意义</strong></p>
<p><strong>2.变量一般用名词</strong></p>
<p><strong>3.函数一般用动词</strong></p>
<p><strong>4.不能与其他关键字同名</strong></p>
<p><strong>操作符规范</strong></p>
<p>操作符左右两侧各保留个空格</p>
<p><strong>单行注释//后加一个空格再写注释</strong></p>
<p><strong>末尾大括号要对齐其父元素</strong></p>
<p><strong>js嵌入HTML</strong></p>
<p><strong>行内式：放置在HTML事件处理程序中</strong></p>
<input type="botton" value="tangbohu" onclick="alert('秋香姐')"> 

<p>注意：</p>
<p><strong>1.可以将单行或少量JS代码写在HTML标签的事件属性中（以on开头的属性），如：onclick</strong></p>
<p><strong>2.注意单双引号的使用：在HTML中我们推荐使用双引号，JS中使用单引号</strong></p>
<p><strong>3.可读性差</strong></p>
<p><strong>4.引号易错，易混淆</strong></p>
<p><strong>5.特殊情况下使用</strong></p>
<p><strong>内联式（直接写在html文件中，一般写在body标签中所有元素后面）</strong></p>
<script>
    alert('sssssss');
</script>



<p><strong>外联式：放置在由<script>标签的src属性指定的外部js文件中</strong></p>
<script type="text/javascript" src="my.js">此处不可写代码</script>

<p><strong>注意：引用外部js文件的script标签中间不可以写代码</strong></p>
<p>执行顺序就是他们在文档中出现的顺序</p>
<p><strong>指定脚本语言</strong></p>
<meta http-equiv="Content-Script-Type" content="text/javascript">

<p><strong>一般浏览器会假设js为默认脚本化语言，如果没有指定默认语言，或者想覆盖默认语言，可以使用type属性</strong></p>
<script type="text/javascript">



**script标记的属性defer、async**

脚本的执行在默认情况下是同步和阻塞的。但是如果有了属性defer或者async，情况会发生变化。

**defer作用：浏览器解析遇到带有defer属性的script标记时，延迟该脚本的执行。文档的载入和解析完成再继续执行**

**async作用：浏览器可以尽快执行脚本，不用在下载脚本时阻塞文档解析。即一边下载js一边解析文档，js**

**如果两者同时都有，那么会遵从async而忽略defer** 



**JS输入输出语句**

**alert（msg）   浏览器弹出警示框** 

**console.log(msg)    浏览器控制台打印输出信息**  

**prompt(info)  浏览器弹出输入框，用户可以输入，输入的是字符串**

**confirm（msg） 浏览器弹出确认框，点击确认返回true，否则返回false**

<script type="text/javascript">
        // 这是一个输入框
        prompt('请输入您的年龄');
        // 弹出警示框 输出展示给用户的
        alert('输入结果是：');
        // console 控制台输出 便于测试
        console.log('我是程序猿');
          //弹出确认框
          var w = confirm("你确定吗?")；
</script>

<p>注意：confirm、prompt、alert都会产生阻塞，但他们弹出时，代码会停止运行。</p>
<p><strong>JS变量</strong></p>
<p><strong>声明和初始化</strong></p>
<p><strong>1.声明变量</strong></p>
<p>// 声明变量  var age; //声明一个名为age的变量 </p>
<p>var=variable</p>
<p><strong>2.赋值</strong></p>
<p>age = 10；  </p>
<p>=表示把右边的值赋予左边的值</p>
<p><strong>变量的初始化</strong></p>
<p>var age=10； </p>
<p><strong>变量语法扩展</strong></p>
<p>var myname='pink老师';         console.log(myname);         myname='pink';         console.log(myname); </p>
<p>变量值只取就近一个</p>
<p><strong>声明多个变量</strong></p>
<p> var age=18, address='火影村', gz=2000; </p>
<p><strong>声明变量的特殊情况</strong></p>
<p> // 1.只声明不赋值 结果为undefined var sex; console.log(sex); // 2.不声明不赋值 直接使用某个变量 结果报错 // console.log(tel); // 不声明直接赋值 结果正确 不推荐  qq =110; console.log(qq); </p>
<p><strong>变量命名规范</strong></p>
<p><strong>1.由字母数字下划线美元符号构成，不能有横杠！！！</strong></p>
<p><strong>2.区分大小写</strong></p>
<p><strong>3.不能数字开头</strong></p>
<p><strong>4.不能是关键字、保留字</strong></p>
<p><strong>5.变量名必须有意义</strong></p>
<p><strong>6.遵守驼峰命名法</strong></p>
<p><strong>7.对于内部使用的函数变量可以用下划线开头结尾的格式命名</strong>  </p>
<p><strong>作用域（变量起作用的范围，可以提高程序的可靠性，减少命名冲突）</strong></p>
<p><strong>作用域类型</strong></p>
<p>1.全局作用域：整个script标签内 或是一个单独的js文件</p>
<p>2.局部作用域：在函数内部，代码名字只在函数内部起效果和作用</p>
<p><strong>根据作用域的不同，变量可分为：1.全局变量 2.局部变量</strong></p>
<p>1.全局变量：在全局起作用的变量</p>
<p>2.局部变量：在局部作用域下的变量（函数内部的变量） 函数形参亦可以看做局部变量</p>
<p>从执行效率看</p>
<p>1.全局变量只有浏览器关闭时才会销毁，比较占内存资源</p>
<p>2.局部变量在程序执行完毕时即销毁</p>
<p><strong>现阶段js没有块级作用域（即花括号包含之内）：函数中声明的所有变量，无论是在那里声明在整个函数中都是有定义的，因为变量提升的原因</strong></p>
<p><strong>全局对象和调用对象</strong></p>
<p><strong>全局对象：当js解释器开始运行时，它首先要做的是在执行任何js代码前创建一个全局对象，而全局变量就是这个全局对象的属性。在客户端JS（嵌入网页的JS）中，这个全局对象就是Window对象</strong></p>
<p><strong>调用对象：每调用一次函数时，会在该函数作用域链前加一个调用对象。函数的参数和局部变量是作为调用对象的属性而存储的。用一个完全独立的对象来存储局部变量使JS可以防止局部变量覆盖同名的全局变量的值</strong></p>
<p><strong>作用域链（为一个对象列表或对象链。在一个**</strong>非嵌套函数中，作用域链由这个函数的调用对象和全局对象组成<strong>**）</strong></p>
<p>内部函数访问外部函数的变量，采取的是<strong>链式查找</strong>的方式根据就近原则来决定取那个值</p>
<script type="text/javascript">
    var num = 10;
    function fn() {
        var num = 20;
        function fun() {
            console.log(num);
        }
        fun();
    }
    fn();
</script>   结果是20



<p><strong>垃圾收集</strong></p>
<p>JavaScript每次创建字符串数组或对象时，解释器都必须f分配内存储存实体</p>
<p>与C、C++不同，js有<strong>垃圾收集</strong>的机制，解释器可以检测何时程序不再使用一个对象，<strong>当确定了对象是无用的时候，会自动释放其占用的内存</strong></p>
<p><strong>数据类型（占用内存大小不同）</strong></p>
<p><strong>js是一种弱类型或者说动态语言，不用提前声明变量的类型，在程序运行过程中，类型会自动被确定，js的变量数据类型只有被赋值后才被确定</strong></p>
<p><strong>相同的变量可用于不同的数据类型</strong></p>
<p><strong>简单数据类型：3种基本数据类型—数字型、字符串型和布尔型，两种小数据类型—null、undefined，还有ES6新增的symbol</strong></p>
<table>
<thead>
<tr>
<th>简单数据类型</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>Number</td>
<td>数字型，包含整型值和浮点型值，如21，0.21</td>
<td>0</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔型，如true、false</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>字符串类型，如“张三”</td>
<td>“”</td>
</tr>
<tr>
<td>Undefined</td>
<td>var a; 声明但没赋值 此时a=undefined</td>
<td>undefined</td>
</tr>
<tr>
<td>Null</td>
<td>var a=null; 声明了变量a为空值</td>
<td>null</td>
</tr>
</tbody></table>
<p><strong>复杂数据类型:对象(object)、数组(array)、函数(function)、日期(Date)、正则表达式(RegExp).本质上都是对象</strong></p>
<p><strong>数字型Number</strong></p>
<p>var num=10; var PI=3.14; var num1=010;    // 数字前面加0，代表八进制 console.log(num1);  // 数字前面加0x，代表16进制 var num2=0x9; var num4=0xa; // 最大值 console.log(Number.MAX_VALUE); // 最小值 console.log(Number.MIN_VALUE);  // 无穷大 console.log(Number.MAX_VALUE * 2);  /<em>输出infinity 无穷大</em>/ // 无穷小 console.log(-Number.MAX_VALUE * 2); /<em>输出-infinity 无穷小</em>/ // 非数值 NaN console.log('ab'-2); /<em>输出NaN</em>/ </p>
<p><strong>isNaN（）；  用来判断非数字 数字返回false 非数字返回true</strong></p>
<p>console.log(isNaN(12));  结果为false console.log(isNaN('dada'));  结果为true </p>
<p><strong>变量.toFixed（n）； 将变量保留n位小数</strong></p>
<p>var num =2.312313; console.log(num.toFixed(3)); // 2.312 </p>
<p><strong>字符串型（不是对象）</strong></p>
<p>语法:双引号或单引号（推荐）</p>
<p>嵌套：外双内单或者外单内双</p>
<p><strong>转义符（以\开头）</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Ce041c65ea275406e8949bbe4d31de77a%5C2635a5dd1182438b98d1fd0ff5f57ebf.jpg" alt="img"></p>
<p><strong>字符串的length属性（用于检测字符串长度）</strong></p>
<script type="text/javascript">
    // 检测获取字符串的长度
    var str = 'my name is andy';
    console.log(str.length);
</script>



<p><strong>字符串拼接</strong></p>
<p>多个字符串之间可以用+拼接，拼接方式为字符串+任何类型=拼接之后的新字符串</p>
<p>数值型和字符型之间也可以相加</p>
<p>口诀：数值相加，字符相连</p>
<script type="text/javascript">
    console.log('woshi'+'haha'); 结果是woshihaha
    console.log('wo'+12);    结果是wo12
    console.log('so'+true);        结果是sotrue
    console.log(12+12);    结果是24
    console.log('12'+12);    结果是1212
    var age=18;
    console.log('陈佳炜'+age+'岁'); 结果是陈佳炜18岁
    age=age+1;
    console.log('陈佳炜'+age+'岁'); 结果是陈佳炜19岁
</script>



<p><strong>布尔型</strong></p>
<p>布尔型有两个值：true和false，其中true表示真，false表示错</p>
<p>布尔型和数字型相加时,true为1，false为0</p>
<p><strong>Undefined</strong></p>
<p><strong>如果使用了一个**</strong>并未声明的变量<strong><strong>时，或者使用了</strong></strong>已经声明但还没有赋值的变量<strong><strong>时，又或者</strong></strong>使用了一个并不存在的对象属性<strong>**时，返回的就是undefined</strong></p>
<p>定义方式</p>
<p>var str; var str=undefined console.log(str+'aa'); 结果为undefinedaa console.log(str+1); undefined和数字相加，最后结果是NaN </p>
<p><strong>布尔环境中，它会转为false。数字环境中，会被转为NaN。字符串环境中，转为“undefined”</strong></p>
<p><strong>Null</strong></p>
<p><strong>即不是有效的对象、数组、数字、字符串和布尔值</strong></p>
<p>定义方式</p>
<p>var b=null; console.log(b); 结果为null console.log(b+'dadad'); 结果为nulldadad console.log(b+1);  结果为1 </p>
<p><strong>布尔环境中，它会转为false。数字环境中，会被转为0。字符串环境中，转为“null”</strong></p>
<p><strong>数据类型转换</strong></p>
<p><strong>转为字符型</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C02d6732e0bfa45c7b8f1f9367ea07aad%5C46e2a276128742e2a6366dbf2fdb0c38.jpg" alt="img"></p>
<p>用法</p>
<p>变量.toString() var num=10; var str=num.toString(); console.log(str); console.log(typeof str);  // console.log(typeof num);  // 利用 String()  // console.log(typeof String(num));  // 利用拼接字符串的方法  console.log(typeof (num+'')); </p>
<p><strong>toString（）可加参数，用来指定转换的基数，如为2，则转为二进制，如为8，则转为八进制，默认为10</strong></p>
<p>var num = 190; num = num.toString(2); console.log(num);// 1011110 </p>
<p><strong>前两种了解即可。推荐使用第三种，亦称为**</strong>隐式转换**</p>
<p><strong>转为数字型（重点）</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C750209ac5e81494b9539319ea9fc2c2a%5Ceb532fea5499406ca0f10e72bbc72dc8.jpg" alt="img"></p>
<p><strong>重点掌握parseInt() parseFloat()</strong></p>
<p>parseInt（）、parseFloat（）会从<strong>字符串开始处</strong>转换和返回<strong>任何的数字</strong>，自动忽略舍去<strong>非数字部分（前提是数字开头）</strong></p>
<p>console.log(parseInt("88 woshi"));// 88 console.log(parseInt("aa 88 woshi"));//NaN </p>
<p>parseInt可以解析<strong>“0x”或“0X"开头的数字</strong>，也可以接受另一个参数指定要解析的数字的基数<strong>(不能解析0开头的数字，除非显性地指定所使用的基数）</strong></p>
<p>console.log(parseInt("ff",16)); </p>
<p>parseInt(变量)  只能转为整数型 var age= prompt('请输入年龄'); console.log(parseInt(age)); console.log(parseInt('3.14'));  //3 取整 console.log(parseInt('120px'));  //会取消px单位 // parseFloat 可以吧字符型的转化为数字型 得到是小数 浮点数 console.log(parseFloat('3.14')); // Number() var str='123'; console.log(Number(str)); // 隐式转换  可以利用- * / 三种符号 console.log('12'-0); </p>
<p>注<strong>:Number()只对10十进制数字有限</strong></p>
<p><strong>转化为布尔型</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cbe1fee6ed519439eb34b329b97e9bee3%5Cc0325a464fa644f2aeae6040cf8431b7.jpg" alt="img"></p>
<p>代表空、否定的值都转化为false，如‘’，0，null，NaN，undefined。其他都转化为true</p>
<p>console.log(Boolean('')); console.log(Boolean(0)); console.log(Boolean(null)); console.log(Boolean(NaN)); console.log(Boolean(undefined)); console.log(Boolean(123)); </p>
<p><strong>运算符</strong></p>
<p>浮点数运算精确度远不如整数，不能直接拿浮点数比较是否相等</p>
<p><strong>表达式：由数字、运算符、变量组成的式子</strong></p>
<p>返回值：表达式返回的值</p>
<p><strong>递增递减运算符</strong></p>
<p>递增运算符（++） 递减运算符（--）</p>
<p>放在变量前面为前置递增 后面为后置递增</p>
<p>前置递增：先运算再取值</p>
<p>后置递增：先取值再运算</p>
<p>单独使用时两者结果相同</p>
<p><strong>比较运算符</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cb11bca1efc004a7a8a310a2372badd16%5C6564ed2d01f54ce7ab07d02dbad1824e.jpg" alt="img"></p>
<p><strong>= 赋值  == 判断（会转型）  ===全等（**</strong>不转型,即判断数据类型和值是否全部相等，对于对象数组函数来说则是判断是否引用同一个地址的对象数组函数<strong>**）</strong></p>
<p><strong>instanceof运算符（判断对象类型）</strong></p>
<p>instance：实例</p>
<p><strong>用于判断是否是某种特殊对象（数组、对象、日期）的实例</strong></p>
<p><strong>要求左边是对象，右边是一个类的名字</strong></p>
<p>var d = newDate(); d instanceof Object;//true </p>
<p><strong>注：instanceof是通过原型对象来判断一个实例属不属于某个构造函数创建的，而不是通过构造函数的名字</strong></p>
<p><strong>利用typeof获取变量数据类型（判断基本类型）</strong></p>
<p><strong>语法：typeof 变量</strong></p>
<p><strong>返回的是字符类型的小写的数据类型名称 'undefined' 'string' 'number' 'function''boolean',对于包装对象和DOM获得的元素返回的都是'object'对象，null和数组返回的是object</strong></p>
<p>var num=10; console.log(typeof num); var str='pink'; console.log(typeof str); var flag=true; console.log(typeof flag); var vari=undefined; console.log(typeof vari); var timer=null; console.log(typeof timer); var age=prompt('请输入年龄'); console.log(typeof age); </p>
<p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th>&&</th>
<th>与</th>
</tr>
</thead>
<tbody><tr>
<td>||</td>
<td>或</td>
</tr>
<tr>
<td>！</td>
<td>非</td>
</tr>
</tbody></table>
<p>如果是布尔值参与逻辑运算，则结果为布尔值</p>
<p>如果是具体数值或表达式参与运算，则发生逻辑中断，其中具体数值代表真，0 ‘’ null undefined NaN代表假</p>
<p>短路运算原理：当有多个表达式时,左边的表达式可以确定结果时，就不再运算右边的表达式的值</p>
<p><strong>表达式1 && 表达式2</strong></p>
<p><strong>如果第一个为真,不足以确定结果，那么就返回表达式2</strong></p>
<p><strong>如果第一个为假，足以确定结果，那么就返回表达式1</strong></p>
<p>console.log(0 && 456);   结果为0 console.log(123 && 456);  结果为456 </p>
<p><strong>表达式1 || 表达式2</strong></p>
<p><strong>如果第一个为真,足以确定结果，那么就返回表达式1</strong></p>
<p><strong>如果第一个为假，不足以确定结果，那么就返回表达式2</strong></p>
<p>console.log(123 || null);  结果为123 console.log(undefined || 456);   结果为456 var num=0; console.log(123 || console.log(num);   结果为0 </p>
<p><strong>赋值运算符</strong></p>
<p>=  赋值  后面赋值给前面</p>
<p>+=x   每次加x  num+=5；  num=num+5</p>
<p>-=x   每年减x  num-=5 ；    num=num-5</p>
<p>*=x 每次乘x</p>
<p>/=x 每次除x</p>
<p>%=x 每次除x取余</p>
<p><strong>运算符优先级</strong></p>
<p>1.小括号</p>
<p>2.一元运算符 ++ -- ！</p>
<p>3.算术运算符 先*/% 再 + -</p>
<p>4.关系运算符</p>
<p>5.相等运算符</p>
<p>6.逻辑运算符 先&& 后||</p>
<p>7.赋值运算符 =</p>
<p>8.逗号运算符， </p>
<p><strong>语句</strong></p>
<p><strong>三种结构</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cf4ef9b5f53a1444d9459dff8adb6fac7%5Ca3c68709572f43c19bf097e3c5b76ca6.jpg" alt="img"></p>
<p><strong>顺序结构：按照代码先后顺序，依次执行</strong></p>
<p><strong>分支结构：根据不同的条件，执行不同的路径代码（if、while）</strong></p>
<p><strong>if分支语句</strong></p>
<p>语法：if（条件表达式）{ 执行语句；}</p>
<p>如果条件表达式结果为真，则执行大括号里面的执行语句</p>
<p>如果条件表达式为假，则跳过if执行后面的代码</p>
<p>if() {} else {}</p>
<p>if（） {} else if {} else if {} else{} 先判断第一个 不符合则判断下一个</p>
<p><strong>三元表达式（由三元运算符？ ： 组成的表达式）</strong></p>
<p>语法结构</p>
<p>条件表达式？ 表达式1:表达式2  如果条件表达式结果为真，则返回表达式1的值，如果为假则返回表达式2</p>
<p><strong>switch语句</strong></p>
<p>switch（表达式） {</p>
<p>case value1： 执行语句1；break；</p>
<p>case value2： 执行语句2；break；</p>
<p>。。。</p>
<p>default：执行最后的语句；</p>
<p>}</p>
<p>匹配case的值，如果匹配，则运行该case里的值，如果都不匹配，则执行default里的值</p>
<p><strong>表达式里的值和case里的值相等是用全等===判定的，即必须是值和数据类型完全一致才可以</strong></p>
<p><strong>必须要有break，否则会执行下一个case</strong></p>
<p><strong>if else if 和switch的区别</strong></p>
<p><strong>1.前者一般用判断范围 后者一般用于确定值</strong></p>
<p><strong>2.前者需要判断多次，后者进行判断后直接执行到程序的条件语句，效率较高</strong></p>
<p><strong>3.分支较少时前者效率高</strong></p>
<p><strong>4.分支多时后者效率高且结构更清晰</strong></p>
<p><strong>循环结构（可重复执行一些代码）</strong></p>
<p><strong>for循环结构</strong></p>
<p>for（初始化变量；条件表达式；操作表达式) { 循环体；}</p>
<p>for()</p>
<p>for() {}</p>
<p>外层循环一次，里面的循环执行全部</p>
<p><strong>断点调试</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C2843de02167643a78053a781447b375a%5Cb34266e0c9ab40d79eb72e08234fd5d9.jpg" alt="img"></p>
<p><strong>while循环结构</strong></p>
<p>while（）{}</p>
<p>记得加入计数器，防止死循环</p>
<p><strong>do{} while（）循环</strong></p>
<p>先执行一次语句，再判断，若正确，则继续执行，否则退出</p>
<p>即循环体至少执行一次</p>
<p>总结：一般若与数字相关，常用for。while和dowhile可以执行更加复杂的循环。while先判断再执行，dowhile先执行再判断</p>
<p><strong>跳转语句</strong></p>
<p><strong>continue</strong></p>
<p>遇到continue就停止本次循环，直接跳到i++，不再执行循环体内continue后面语句</p>
<p>for (var i =1;i<=5;i++) {     if (i==3) {         continue;     }     console.log('我正在吃第'+i+'个包子'); } </p>
<p>结果</p>
<p>我正在吃第1个包子</p>
<p>我正在吃第2个包子</p>
<p>我正在吃第4个包子</p>
<p>我正在吃第5个包子</p>
<p><strong>break</strong></p>
<p>遇到break直接跳出此循环所属的for语句的所有循环</p>
<p>for(var i=1;i<=5;i++) {     if(i==3) {         break;     }     console.log('我正在吃第'+i+'个包子') } </p>
<p>结果</p>
<p>我正在吃第1个包子</p>
<p>我正在吃第2个包子</p>
<p><strong>throw</strong></p>
<p>用于抛出异常，用信号通知发生了错误或者异常状况</p>
<p>异常：发生了某种异常情况或错误时产生的一个信号。</p>
<p>语法格式：</p>
<p>throw expression；</p>
<p>expression可以使任意类型，一般为Error对象</p>
<p>function twoArg(o,t) {     if(arguments.length !== 2)          throw new Error('必须是两个参数'); } twoArg(1); </p>
<p>注意:当抛出异常时，JS解释器会停止当前正在执行的逻辑，跳转到最近的异常处理程序（即后面try/catch/finally中catch语句编写的程序）</p>
<p><strong>try/catch/finally</strong></p>
<p>try用于检查抛出异常</p>
<p>catch用于抓住异常，其参数便是try抛出的值</p>
<p>finally内的代码无论如何总会执行</p>
<p>try {             var n = prompt('enter a number');             // var t = prompt('enter a number');             if(n == 1) {                 throw 'wocao';             }         }         catch(e) {             alert(e);//wocao         } </p>
<p>注意：</p>
<p>1.try后面至少要跟随一个catch或者finally</p>
<p>2.catch的参数有局部作用域，只在catch语句中有效</p>
<p>3.如果没有catch从句，执行finally后会向上传播异常，直到找到能处理这个异常的catch从句</p>
<p><strong>数组（一组数据的集合）</strong></p>
<p><strong>创建方式：</strong></p>
<p><strong>1.利用new关键字创建数组</strong></p>
<p>var arr = new Array(); </p>
<p><strong>2.利用数组字面量创建数组</strong></p>
<p>var arr = ['a','b','c','d','e']; var arr = [1，2，‘dada'，true]; var arr=[]; </p>
<p>注意</p>
<p><strong>1.数组里面可以放任何数据类型</strong></p>
<p><strong>2.数组里面的数据称为数组元素</strong></p>
<p><strong>数组的索引</strong></p>
<p><strong>索引：用来访问数组元素的序号（**</strong>从0开始，最大为2^32 - 1<strong>**）</strong></p>
<p>数组的长度是元素个数，不要跟索引号混淆</p>
<p><strong>数组的遍历</strong></p>
<p><strong>遍历：就是把数组中的所有元素从头到尾访问一次；</strong></p>
<p>数组名.length:动态监测数组元素的个数，一般循环遍历时长度都用这个来表示</p>
<p>for(i=0;i<date.length;i++) { alert(date[i]); } </p>
<p><strong>数组元素增加</strong></p>
<p><strong>1.通过修改length新增数组元素</strong></p>
<p>先修改数组长度，再对新增元素赋值</p>
<p>若修改后的长度<原先的长度，则原数组会被截取。若修改后的长度>原先的长度，则原数组会添加多余个数的undefined</p>
<p> arr.length=5; arr[3]=4; arr[4]=5; </p>
<p><strong>2.通过修改数组索引的方式增加数组元素</strong></p>
<p>直接对未赋值的数组元素赋值，若赋值的索引号已被占用，则会被替换为新的元素值</p>
<p>var arr = [1, 2, 3]; arr[3]=4; </p>
<p><strong>注意：不要对数组名直接赋值，否则会清除所有数组元素</strong></p>
<p><strong>函数（封装了一段可被重复调用执行的代码块，通过函数可以实现大量代码的重复使用)</strong></p>
<p><strong>函数使用步骤：1.声明函数 2.调用函数</strong></p>
<p><strong>1.声明函数</strong></p>
<p><strong>声明方式1：</strong></p>
<p><strong>function 函数名（参数1，参数2，...）{ 函数体；}</strong></p>
<p><strong>注意：</strong></p>
<p><strong>1.function为声明函数的关键字，全部小写</strong></p>
<p><strong>2.函数名一般为动词，代表此函数要做什么</strong></p>
<p><strong>3.函数声明后被调用才能执行，不调用不执行</strong></p>
<p><strong>4.函数声明一般出现在js代码的顶层，也可以嵌套在其他函数中，但是只能嵌套在那些函数顶层中，不能出现在if，while或其他语句中</strong></p>
<p><strong>5.使用可选参数设计函数时，应该确保把可选的参数放参数列表的末尾</strong></p>
<p>function sayHi() {     alert('hi'); }     </p>
<p><strong>声明方式2：</strong></p>
<p><strong>var 变量名=function（参数1，参数2，...）{}； （匿名函数）</strong></p>
<p> var fun = function() {      console.log('我是傻逼');  } </p>
<p><strong>2.函数调用</strong></p>
<p><strong>函数名()；</strong></p>
<p>sayHi（）； </p>
<p>或者</p>
<p><strong>变量名（）; 针对第二种声明方式</strong></p>
<p>fun(); </p>
<p>注意：</p>
<p>调用函数时一定记得写小括号</p>
<p><strong>函数的参数：形参 实参</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Ce42fdae07684433f888f863dcdc1f29a%5C2859bb1fd22540a9a9a09ae212cc4a4a.jpg" alt="img"></p>
<p>多个参数之间逗号隔开</p>
<p><strong>如果实参个数多于形参个数，会取到形参的个数</strong></p>
<p><strong>如果实参个数小于形参的个数，没有赋值的形参则为undefined，结果为NaN</strong></p>
<p><strong>调用数组时直接写数组名字或者整个数组元素即可</strong></p>
<p><strong>函数返回值</strong></p>
<p>函数只是实现某种功能，最终结果需要return返回数值，return只能返回一个值</p>
<p>函数如果没有return，返回的是undefined</p>
<p><strong>return也有终止函数的功能</strong></p>
<p>可以利用数组实现返回多个值</p>
<p>function getResult(num1,num2) {     return [num1+num2, num1 - num2,num1 * num2, num1 / num2]; } var re= getResult(1,2); console.log(re); </p>
<p><strong>arguments的使用（存储函数传递的所有实参）</strong></p>
<p><strong>arguments是Arguments对象的实例，是当前函数的一个内置对象，所有函数都内置了一个arguments对象，**</strong>arguments只能在函数中调用，<strong><strong>可以按照数目获取函数的</strong></strong>实参<strong><strong>的参数值（</strong></strong>调用函数时写的参数而不是定义函数时写的形参<strong>**）</strong></p>
<p>当不确定有多少个参数传递的时候，可以用arguments来获取。</p>
<p>function fn() {     console.log(arguments); } fn(1,2,3); </p>
<p>arguments是一个伪数组，可以进行遍历，特点如下：</p>
<p><strong>1.具有length属性</strong></p>
<p><strong>2.按索引方式储存数据</strong></p>
<p><strong>3.不具有数组的push、pop等方法</strong></p>
<p><strong>arguments的属性</strong></p>
<p><strong>arguments.callee:返回arguments所在的函数</strong></p>
<p>function whoIsCalling() {     console.log(arguments.callee); } whoIsCalling();//返回whoIsCalling函数的代码 </p>
<p>该属性可用来实现回调</p>
<p><strong>在JS中，代码可以对函数进行操作。JS中的函数是真正的数据，可以被存储在变量中、数组和对象中，可以作为参数传递给其他函数</strong></p>
<p><strong>函数的属性方法</strong></p>
<p><strong>函数.length</strong></p>
<p><strong>返回函数**</strong>定义时<strong>**形参的个数</strong></p>
<p>function f(x,y) {     console.log(f.length);//2     console.log(arguments.length);//3 } f(1,2,3)； </p>
<p><strong>JS的预解析（小难点，看案例）</strong> </p>
<p><strong>js引擎运行分两步：</strong></p>
<p><strong>1.预解析：js引擎会把js里面所有的var 和 function提升到**</strong>当前作用域最前面**</p>
<p><strong>2.代码执行：按书写顺序依次执行代码</strong></p>
<p><strong>预解析分为：</strong></p>
<p><strong>1.变量预解析（变量提升）：把var提升到当前作用域的最前面，但不赋值</strong></p>
<p>function fun() {     console.log(num); } fun(); var num=10; 等价于 var num; function fun() {     console.log(num); } fun(); num=10;  fn(); var fn=function() {     console.log(11); } 等价于 var fn; fn(); fn=function() {     console.log(11); } </p>
<p><strong>2.函数预解析（函数提升）：把所有函数声明提升到当前作用域最前面，但不调用函数</strong></p>
<p>con(); function con() {     console.log(11); } 等价于 function con() { console.log(11); } con(); </p>
<p><strong>注意：var a=b=c=9； 预解析后等于var a；a=9；b=9;c=9; b和c变成全局变量</strong></p>
<p><strong>JS的对象</strong></p>
<p><strong>对象：**</strong>一组无序的相关属性和方法的集合，所有的事物 都是对象，<strong>**除了字符串、数字、true、false、null和undefined其他都是对象（事实上字符串数字布尔值可以被包装为包装对象）</strong></p>
<p><strong>对象由属性和方法构成</strong></p>
<p><strong>属性：事物的特征，在对象中用属性来表示（常用名词），属性值可以是任意的js表达式，等同于变量。</strong></p>
<p><strong>属性两种类型：</strong></p>
<p><strong>自有属性：直接在对象中定义的属性</strong></p>
<p><strong>继承属性：通过原型对象继承的属性</strong></p>
<p><strong>属性的三个特性：</strong></p>
<p><strong>值（value）：属性的值</strong></p>
<p><strong>可写（writable）：表明是否可以设置该属性的值</strong></p>
<p><strong>可枚举（enumerable）：表示是否可以通过for/in循环返回该属性</strong></p>
<p><strong>可配置（configurable）：表明是否可以删除或者修改该属性</strong></p>
<p><strong>方法：事物的行为，在对象中用方法来表示（常用动词），即存储在对象中的函数</strong></p>
<p><strong>对象有三种：1.自定义对象 2.内置对象 3.宿主对象 （前两者属于ECMAscript，后者属于客户端JavaScript）</strong></p>
<p><strong>创建对象</strong></p>
<p><strong>1.用字面量创建对象</strong></p>
<p><strong>var 对象名 = { 属性名： ‘属性值’，属性名： ‘属性值’，。。。}</strong></p>
<p>var obj = {     uname: '张三疯',     age: 18,     sex: '男',     sayHi: function() {         console.log('Hi');     } } </p>
<p><strong>调用对象</strong></p>
<p><strong>1.对象名.属性名</strong> </p>
<p><strong>2.对象名['属性名']（即作为关联数组的对象，允许动态地将任意数值和任意字符串关联在一起）</strong></p>
<p> console.log(obj.uname);  // (2) 第二种方法 对象名['属性名']  console.log(obj['age']); </p>
<p> <strong>变量、属性、函数、方法的区别</strong></p>
<p><strong>1.变量和属性都是用来存储数据，但变量需要声明属性不需要，变量可以直接写变量名调用，属性必须对象名.属性名调用，变量和属性基本等同</strong></p>
<p><strong>2.函数和方法都是实现某种功能。函数是单独声明且调用时是写函数名（）。方法在对象里声明且调用为 对象.方法（），对象中的函数即为方法</strong></p>
<p><strong>2.用new Object 创建对象</strong></p>
<p><strong>利用等号对属性进行赋值</strong></p>
<p>var obj = new Object(); obj.uname = '张三疯'; obj.age  = 18; obj.sex = '男'; obj.sayHi = function() {     console.log('Hi'); } </p>
<p><strong>调用对象</strong></p>
<p>console.log(obj.uname); console.log(obj.sex); obj.sayHi();     </p>
<p><strong>3.利用构造函数构造多个对象</strong></p>
<p><strong>构造函数：就是把对象里面一些相同的属性和方法抽出封装起来的函数，即构造对象的函数</strong></p>
<p>function 构造函数名(形参) {     this.属性 = 值;     this.方法 = function() {} } </p>
<p><strong>var 对象名 = new 构造函数名（实参）；</strong></p>
<p>function Star(uname,age,sex) {             this.name = uname;             this.age = age;             this.sex = sex;         }      var ldh = new Star('ldh',18,'male');  </p>
<p>注意点以及构造函数执行过程：</p>
<p><strong>1.构造函数名字首字母一般大写</strong></p>
<p><strong>2.构造函数不需要return</strong></p>
<p><strong>3.调用构造函数 必须使用new new构造函数在内存中创建了一个空的对象</strong></p>
<p><strong>4.必须使用this，this指向new创建的空对象</strong></p>
<p><strong>5.执行构造函数的代码后，就会给这个空对象添加属性和方法</strong></p>
<p><strong>6.new会返回创建后的对象</strong></p>
<p><strong>遍历对象</strong></p>
<p><strong>语法： for（变量 in 对象） {}</strong></p>
<p>for(var k in obj) {     console.log(k); // 遍历输出属性名     console.log(obj[k]); //遍历输出属性值 } </p>
<p>注意:</p>
<p>1.k可以改为任意变量名，一般用k</p>
<p>2.k为数组</p>
<p><strong>3.也可以用于数组！！！</strong></p>
<p>4.该方法会<strong>枚举所有可枚举的属性，包括自有属性和继承属性</strong>（除非利用Object.defineProperty（）人为设定为不可枚举）</p>
<p><strong>5.许多预定义内部属性和方法，包括所有的内部方法都是不可枚举的</strong></p>
<p><strong>删除属性</strong></p>
<p><strong>语法：delete 属性</strong></p>
<p>删除运算数指定的<strong>对象的属性、数组元素或变量</strong>（严格模式不可删除）。返回布尔值</p>
<p>内部核心属性、客户端属性、用var语句声明的用户定义变量都不能删除</p>
<p>var obj = {     num:10,     age:20 } delete obj.num; console.log(obj);// num消失 </p>
<p><strong>注意：</strong></p>
<p>delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性</p>
<p><strong>检查属性的存在性</strong></p>
<p>1.检测对象或数组中是否有某个属性，返回布尔值</p>
<p><strong>语法：属性名 in 对象或数组</strong></p>
<p>var obj = {     num:10,     age:20 } console.log("num" in obj);//true </p>
<p><strong>注意：**</strong>该方法可以检测所有的属性方法，包括自定义类内置的和原型链上的以及原始类的属性方法**</p>
<p>2.只能检测对象的自有属性</p>
<p><strong>语法：对象.hasOwnProperty(属性名） 返回布尔值</strong></p>
<p>function Star() {         this.name = 1     }     Star.prototype.age =12;     Object.prototype.male = 'man';     var ldh = new Star();      console.log(ldh.hasOwnProperty('name'));//true     console.log(ldh.hasOwnProperty('male'));//false </p>
<p><strong>确定对象类型</strong></p>
<p><strong>1.typeof：用于区分number、string、boolean、undefined、function、symbol这些基本类型</strong></p>
<p><strong>2.instanceof：一旦确定了一个值不是基本类型或函数，就可以用instanceof来确定是哪种内建对象的实例,对于基本类型包装对象无效</strong></p>
<p><strong>3.Object.toString（）：返回的是[object class]，class是对象的内部类型，通常与该对象的构造函数名字对应。如Array,Function,Date,Math</strong></p>
<p><strong>4.constructor:返回原型对象所属的类，返回的是整个构造函数</strong></p>
<p><strong>序列化对象（将对象的状态转为字符串或将字符串还原为对象）</strong></p>
<p><strong>利用JSON.stringify（）和JSON.parse()来序列化和还原对象</strong></p>
<p><strong>JSON（JavaScript Object Notation）:JavaScript对象表示法</strong></p>
<p><strong>内置对象</strong> </p>
<p>常用 Math Date Array String等</p>
<p><strong>1.数学对象</strong></p>
<p>不是构造函数，无需用new调用。而是可以直接调用其类属性及类方法</p>
<p><strong>调用属性 如 输出pi值 Math.PI</strong></p>
<p>console.log(Math.PI); // 3.14.... </p>
<p><strong>调用方法 如 取最大值 Math.max</strong></p>
<p>console.log(Math.max(1,2,3)); // 3 </p>
<p>如果有一个或一个以上的值为非整数型，则返回NaN</p>
<p>如果没有赋值，则返回-Infinity</p>
<p><strong>求开根号 Math.sqrt(x)  返回x的开根号值</strong></p>
<p>var x = Math.sqrt(81); console.log(x); </p>
<p><strong>求绝对值 Math.abs</strong>  </p>
<p>console.log(Math.abs(1)); //1 console.log(Math.abs(-1)); // 1 console.log(Math.abs('-1'));  // 1 有隐式转换 可以直接字符串转为数字型 console.log(Math.abs('哈哈'); // NaN </p>
<p><strong>三个取整方法</strong></p>
<p><strong>1.Math.floor（） 向下取整，往最小了取值,不会四舍五入</strong></p>
<p>console.log(Math.floor(1.1)); // 1 console.log(Math.floor(1.9)); // 1 </p>
<p><strong>2.Math.ceil（）  往上取整，往最大了取，不会四舍五入</strong></p>
<p>console.log(Math.ceil(1.9)); // 2 console.log(Math.ceil(1.1)); // 2 </p>
<p><strong>3.Math.round() 四舍五入取整**</strong>（其他都是四舍五入，只有5是往大了取）**</p>
<p>console.log(Math.round(1.1)); // 1 console.log(Math.round(1.9)); // 2 console.log(Math.round(-1.5)); // -1 </p>
<p><strong>随机数</strong></p>
<p><strong>Math.random() 返回一个随机的0到1之间的小数（不包含0和1）且不跟参数</strong></p>
<p>得到两个整数之间的随机整数：</p>
<p>function getRandom(min,max) {     console.log(Math.floor(Math.random()*(max-min+1)+min));   } </p>
<p><strong>2.日期对象</strong></p>
<p><strong>Date() 日期对象 是一个构造函数 必须使用new来调用创建自己的日期对象</strong></p>
<p>使用方法</p>
<p>var date = new Date(); console.log(date); </p>
<p>参数写法</p>
<p><strong>无参数则返回当前系统时间</strong></p>
<p>数字型：2019，10，01    字符型：’2019-10-1 8：8：8‘</p>
<p>var date1 = new Date(2019,10,1); or var date2 = new Date('2019-10-1 8:8:8'); </p>
<p>具体方法</p>
<p><strong>返回当前年份</strong></p>
<p><strong>对象名.getFullYear()</strong> </p>
<p><strong>返回当前月份</strong></p>
<p><strong>对象名.getMonth()+1</strong></p>
<p><strong>注意：是从0开始到11 所以应该+1 否则得到的月份少一个月</strong></p>
<p><strong>返回当前号数</strong></p>
<p><strong>对象名.getDate()</strong> </p>
<p><strong>返回周几</strong></p>
<p><strong>对象名.getDay()</strong> </p>
<p><strong>注意：是从0（即星期日）开始到6（星期六）</strong></p>
<p><strong>返回小时</strong></p>
<p><strong>对象名.getHours();</strong></p>
<p><strong>返回分钟</strong></p>
<p><strong>对象名.getMinutes()</strong></p>
<p><strong>返回秒钟</strong></p>
<p><strong>对象名.getSeconds()</strong></p>
<p><strong>返回自1970年来的总毫秒数</strong></p>
<p><strong>1.对象名.getvalueOf() 或者 对象名.getTime()</strong></p>
<p><strong>2.var 对象名 = +new Date();</strong></p>
<p><strong>3.console.log(Date.now())   低版本浏览器不支持</strong></p>
<p><strong>3.数组对象</strong></p>
<p>创建方式</p>
<p><strong>1.利用字面量</strong></p>
<p>var arr = [1,2,3]; console.log(arr[0]); </p>
<p><strong>2.利用new Array()</strong></p>
<p>var arr1 = new Array(); //空数组 var arr2 = new Array(2); //长度为2的空数组 var arr3 = new Array(2,3);// 内容为2和3的数组 </p>
<p><strong>检测变量是否为数组的方法</strong></p>
<p><strong>1.利用 instanceof</strong></p>
<p><strong>变量名 instanceof Array</strong> </p>
<p>返回的是布尔值</p>
<p>var arr = []; var obj = {}; console.log(arr instanceof Array); // 返回true console.log(arr instanceof Array); // 返回false </p>
<p>注：亦可用来判断是否为对象类型 ：变量名 instanceof Object</p>
<p><strong>2.利用Array内置对象的行为</strong></p>
<p><strong>Array.isArray（变量）</strong></p>
<p>返回的也是布尔值</p>
<p>Array.isArray([1,2,3]); // TRUE Array.isArray(1,2,3); // FALSE </p>
<p><strong>给数组添加元素的方法</strong></p>
<p><strong>1.末尾添加</strong></p>
<p>数组名.push（元素1，元素2，...）； </p>
<p>var arr = [1,2,3]; arr.push(1,'dada'); // 返回结果是数组长度 </p>
<p><strong>2.头部添加</strong></p>
<p>数组名.unshift（元素1，元素2，...）;</p>
<p>var arr = [1,2,3]; arr.unshift('red','purple');  // 返回结果是数组长度 </p>
<p><strong>3.尾部删除</strong></p>
<p>数组名.pop（）</p>
<p>arr.pop(); //pop没有参数 返回删除的元素 一次只能删除一个元素 </p>
<p><strong>4.头部删除</strong></p>
<p>数组名.shift()</p>
<p>arr.shift() //没有参数 返回删除的元素 一次只能删除一个 </p>
<p>总结</p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C626a3cafae634dc899997633d8cc7dbd%5Cd0925c276df34b83870456b2f29fc12e.jpg" alt="img"></p>
<p><strong>数组排序的方法</strong></p>
<p><strong>1.数组翻转</strong></p>
<p><strong>数组名.reverse（）；</strong></p>
<p>var arr = [1,2,3]; arr.reverse(); console.log(arr); </p>
<p><strong>2.数组排序</strong></p>
<p><strong>数组名.sort（）； 只对一位数起效，多位数会出错</strong></p>
<p><strong>数组名.sort(function(a,b) { a - b})  升序排序</strong></p>
<p><strong>数组名.sort(function(a,b) { b - a})  降序排序</strong></p>
<p>var arr1 = [3,4,8,12]; arr1.sort(function(a,b) {     // return a - b;  升序排列     return b - a; }); </p>
<p><strong>获取数组元素索引方式</strong></p>
<p><strong>1.变量名.indexOf(元素值);</strong></p>
<p>var arr = ['red','green','pink','blue'] console.log(arr.indexOf('blue')); </p>
<p>注：返回第一个满足条件的索引号 </p>
<p><strong>如果该数组里找不到元素，则返回-1</strong></p>
<p><strong>2.变量名.lastIndexOf（元素值）；</strong></p>
<p>注：从末尾开始找 返回正序的索引号</p>
<p>console.log(arr.lastIndexOf('blue')) </p>
<p>注：只能用于数组，不能用于节点</p>
<p><strong>数组转为字符串</strong></p>
<p><strong>1.变量名.toString（）；</strong></p>
<p>var arr = [1,2,3]; console.log(arr.toString()); </p>
<p><strong>2.变量名.join();</strong></p>
<p>把数组所有元素转换成字符串，再把它们连接起来。可以指定一个可选的字符串来分隔结果字符串中的元素。默认为逗号分隔</p>
<p>var arr1 = ['green','blue','pink']; console.log(arr1.join());//green,blue,pink console.log(arr1.join(''));//greenbluepink </p>
<p><strong>数组的截取删除连接</strong></p>
<p><strong>数组链接</strong></p>
<p>数组名1.concat（数组名2）；</p>
<p>数组名1.concat（元素值,元素值,...）；</p>
<p>var num1 = [1,2,3]; var num2 = ['a','b','c']; console.log(num1.concat(num2)); console.log(num1.concat(num2,1,[2,3])); </p>
<p><strong>数组删除插入（改变原数组,返回被删除的值）</strong></p>
<p><strong>数组名.splice(起始位置，删除个数，添加元素）</strong></p>
<p>var num3 = ['ha','xi','hei','he']; var num4 = num3.splice(1,0,'en'); // 在第1位后插入'en' var num5 = num3.splice(1,1); //第1位开始删除一位  console.log(num5); // 'xi' var num6 = num3.splice(2,1,'en','o'); console.log(num3);// 'ha' 'xi' 'en' 'o' 'he' </p>
<p><strong>数组截取(不会改变原数组，只是截取出来作为新数组）</strong></p>
<p><strong>数组名.slice(开始位置（包含），结束位置（不包含））；</strong></p>
<p>var num7 = [1,2,3,4,5,6]; console.log(num7.slice(2)); // 3,4,5,6 console.log(num7.slice(1,3));// 2,3 // num7依旧为1，2，3，4，5，6 </p>
<p><strong>4.字符串对象</strong></p>
<p><strong>基本包装类型：js不仅支持数字字符串和布尔值这些数据类型，还支持Number、String、Boolean类，这些类是其对应基本数据类型的包装。不仅具有和基本类型一样的值，还定义了用来运算数据的属性和方法</strong></p>
<p>过程：</p>
<p>（1）字符串值内部创建一个String包装对象</p>
<p>var temp = new String(字符串值)</p>
<p>(2)代替原始的字符串值</p>
<p>变量名 = temp；</p>
<p>（3）销毁temp</p>
<p>temp=null;</p>
<p><strong>字符串不可变性：字符串赋值后重新赋值需要重新创建内存空间，原先的内存及其值不变。所以不要大量拼接字符串，即字符串的值无法修改</strong></p>
<p><strong>字符串所有方法，都不会修改字符串本身内容，而是创建新的字符串</strong></p>
<p><strong>实例方法</strong></p>
<p><strong>根据字符串返回索引值</strong></p>
<p><strong>字符串名.indexOf（具体某个字符串，开始位置（默认无））;</strong></p>
<p>var str ='改革春风吹满地,春天来了'; console.log(str.indexOf('春')); // 返回2 console.log(str.indexOf('春',3)); // 返回8 </p>
<p><strong>根据索引值返回字符串</strong></p>
<p><strong>1.字符串变量名.charAt(索引值）</strong></p>
<p>var str='1234'; var a = str.charAt(1); </p>
<p><strong>2.字符串变量名.charCodeAt(索引值） 返回对应位置字符的ASCII码 用于判断用户按键</strong></p>
<p>console.log(str.charCodeAt(0)); </p>
<p><strong>3.变量名[索引值]</strong></p>
<p>console.log(str[1]); </p>
<p><strong>字符串连接</strong></p>
<p>字符串1.concat（字符串2）；</p>
<p>字符串1.concat（字符,字符,...）；</p>
<p>一般用加号</p>
<p><strong>字符串截取</strong></p>
<p><strong>字符串.substr（截取起始位置，截取的字符数） 不改变原字符串</strong></p>
<p>var str = '改革春风吹满地'; console.log(str.substr(2,2)); </p>
<p><strong>字符串替代</strong></p>
<p><strong>字符串.replace（‘被替换的字符’，‘替换为的字符’）</strong></p>
<p>返回的是新修改后的字符串，原字符不变</p>
<p>var str='andy'; console.log(str.replace('y','d')); // 有一个字符串'abcoefoxyozzopp' 要求把所有o替换为* var str1='abcoefoxyozzopp'; for(i=0;i<str1.length;i++) {     str1 = str1.replace('o','*'); } </p>
<p><strong>字符串转为数组</strong></p>
<p><strong>字符串.split（‘分隔符’）</strong></p>
<p>原字符串用什么分割，就用什么做分隔符 不改变原字符串</p>
<p>var str1 = 'red,pink,blue'; console.log(str1.split(',')); var str3 = 'red&pink&blue'; console.log(str3.split('&')); </p>
<p><strong>字符串大小写转换</strong></p>
<p><strong>字符串.toUpperCase（） 将字符串转为大写</strong></p>
<p><strong>字符串.toLowerCase（） 将字符串转为大写</strong></p>
<p><strong>注：字符串大小比较是按对应字母一个一个比</strong></p>
<p><strong>去除字符串左右的空格</strong></p>
<p><strong>字符串.trim()</strong></p>
<p><strong>可用来去除表单只填入空格时造成的bug</strong></p>
<p><strong>判断字符串开头结尾</strong></p>
<p><strong>字符串.startsWith('xxx');  判断str字符串是否以xxx开头</strong></p>
<p><strong>字符串.endsWith('xxx');  判断str字符串是否以xxx结尾</strong></p>
<p>let str = 'hello myworld'; // startsWith 判断字符串是否以某字符串开头 返回布尔值 console.log(str.startsWith('he'));//true // endsWith 判断字符串是否以某字符串结尾 返回布尔值 console.log(str.endsWith('rld'));//true </p>
<p><strong>重复某个字符串</strong></p>
<p><strong>字符串.repeat(n) 将字符串str重复n次，返回新的，不改变旧的</strong></p>
<p>let str = 'x'.repeat(5); console.log(str); str1 = str.repeat(2); console.log(str1); </p>
<p><strong>类方法</strong></p>
<p><strong>根据ASCII码返回字符串</strong></p>
<p><strong>String.fromCharCode(***</strong>num1<strong>***,</strong> <strong><em>...**</em></strong>,** <strong><em>numN**</em></strong>)**</p>
<p>console.log(String.fromCharCode(78));//N </p>
<p><strong>简单和复杂数据类型</strong></p>
<p><strong>简单数据类型（基本数据类型或值类型）：存储时变量中存放的是值本身，因此叫值类型，如number、boolean、undefined、null。都具有固定的内存大小</strong></p>
<p><strong>其中null的返回类型是Object，因此一般可先用来定义对象</strong></p>
<p>var timer = null; console.log(typeof null); //结果为object </p>
<p>如果有个变量打算存储为对象但没想好放什么属性和行为，那么就可以先设置为null类型</p>
<p><strong>复杂数据类型（引用类型）：变量中存储的仅仅是地址，如对象及其特殊类型数组和函数</strong></p>
<p><strong>其中字符串不能很好地适合基本类型和引用类型的二分法。因为字符串不是对象，被当做基本类型，而字符串又有任意的长度，所以也可以被认为是引用类型。字符串是通过传值来比较</strong></p>
<p><strong>堆和栈</strong></p>
<p><strong>栈：存放简单数据类型，由操作系统自动分配释放存放函数的参数值、局部变量的值等。简单数据类型直接查找存放在栈中的变量的值（简单数据>栈>变量>值）</strong></p>
<p><strong>堆：存放复杂数据类型，一般由程序员分配释放。复杂数据类型通过存放在栈中的变量中的地址找到存放在堆中的值（复杂数据>栈>变量>地址>堆>值）</strong></p>
<p><strong>简单数据类型的传参（传值）</strong></p>
<p><strong>函数的形参可以看做一个变量，当把一个变量传给函数形参就等于把变量的值复制一份给形参。所以对函数内变量的修改不会影响外部变量</strong></p>
<p><strong>复杂数据类型的传参（传址）</strong></p>
<p><strong>函数的形参可以看做一个变量，当把一个变量传给函数形参就等于把变量存放的堆地址复制一份给形参，即形参和实参保存的是同个堆地址，所以操作的是同一个对象。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>浏览器</title>
    <url>/2020/02/03/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<p>浏览器内核包括：渲染引擎，JS引擎</p>
<p>内核种类：Trident（IE浏览器）、Gecko（firefox浏览器）、webkit（safari浏览器）、chromiun/blink（chrome浏览器）、presto（opera浏览器 后改用blink内核）</p>
<p>web标准：</p>
<p>1、结构标准：XML和XHTML </p>
<p>2、样式标准： CSS</p>
<p>3、行为标准：JS</p>
]]></content>
  </entry>
  <entry>
    <title>css</title>
    <url>/2020/02/03/css/</url>
    <content><![CDATA[<p><strong>CSS样式规则</strong></p>
<p>格式：选择器{ 属性：属性值；属性：属性值；}</p>
<p>规则：</p>
<ol>
<li>选择器用于指定CSS样式作用的html对象，花括号内是具体的样式</li>
<li>属性和属性值以“键対值”的形式出现 </li>
<li>属性是对指定的对象设置的样式属性，例如字体大小，文本颜色等</li>
<li>属性和属性值之间用英文”:”链接 不是等号</li>
<li>多个键值对之间用英文”;”区分</li>
</ol>
<p><strong>字体设置</strong></p>
<p>CSS Unicode字体</p>
<p>微软雅黑 \5FAE\8F6F\96C5\9ED1</p>
<p>宋体 \5B8B\4F53</p>
<p>尽量只写unicode字体 写宋体和微软雅黑</p>
<p>CSS中注释方式：/<em>xxxxx</em>/ </p>
<p><strong>设置字体样式：font-family:**</strong>”<strong><strong>xxx</strong></strong>”**</p>
<p><strong>设置字体字号：font-size:**</strong>”<strong><strong>xxpx</strong></strong>”**</p>
<p><strong>字体字号常用技巧：</strong></p>
<p><strong>网页中正文普遍使用**</strong>14px**</p>
<p><strong>若有设置多个字体，则字体之间应用**</strong>英文逗号隔开**</p>
<p><strong>中文字体需要加英文双引号**</strong>，英文字体不需要，且<strong>**英文字体应在中文字体之前</strong></p>
<p><strong>若字体中包**</strong>含空格、π、$等符号<strong><strong>，无论是英文还是中文字体都</strong></strong>必须加引号**</p>
<p><strong>尽量使用系统默认字体</strong></p>
<p><strong>设置字体粗细</strong></p>
<p><strong>Font-weight:</strong></p>
<p><strong>可用属性值包括normal（即400）、bold（即700）、bolder、lighter、100-900之间100的整倍数</strong></p>
<p><strong>设置字体风格</strong></p>
<p><strong>Font-style:</strong></p>
<p><strong>可用属性值包括normal,italic(斜体)</strong></p>
<p><strong>字体综合设置</strong></p>
<p><strong>选择器{font：font-style font-weight font-size/line-height font-family；}</strong></p>
<p><strong>注意：</strong></p>
<p><strong>不能更换顺序，以空格隔开</strong></p>
<p><strong>不需要设置的属性可以忽略</strong></p>
<p><strong>选择器</strong></p>
<p><strong>标签选择器</strong> </p>
<p>格式：</p>
<p>标签名{属性1：属性值1；属性2：属性值2；属性3：属性值3；}</p>
<p><strong>类选择器</strong></p>
<p>格式</p>
<p>.类名{属性1：属性值1；属性2：属性值2；属性3：属性值3；}</p>
<p>标签调用时用class=“类名”即可</p>
<p>命名规范：</p>
<ol>
<li>长名称或词组可以使用中横线来为选择器命名</li>
<li>不建议使用“_”下划线命名css选择器</li>
<li>不要纯数字、中文等命名，尽量使用英文字母</li>
</ol>
<p><strong>多类名选择器</strong></p>
<p>即一个标签带多个类名，从而实现灵活自由搭配</p>
<p>例：<div class="font20 blue">傻逼</div></p>
<pre><code>&lt;div class=&quot;font14 blue&quot;&gt;憨憨&lt;/div&gt;

&lt;div class=&quot;font20 orange&quot;&gt;傻逼&lt;/div&gt;

&lt;div class=&quot;font14 orange&quot;&gt;傻逼&lt;/div&gt;</code></pre><p>1.样式显示效果跟html中的类名先后顺序无关</p>
<p>2.各个类名中间用空格隔开</p>
<p><strong>交集选择器</strong></p>
<style>

标签名.类名{}

</style>



<p><strong>并集选择器</strong></p>
<style>

标签名,

标签名,

标签名,

标签名{}      一般上下写

</style>



<p><strong>Id选择器</strong></p>
<p>语法格式：</p>
<p>#id名{}</p>
<p><xx id=””></xx></p>
<p><strong>Id与类选择器区别：一个id只能用于一个标签，类可以用于多个标签。</strong></p>
<p><strong>链接伪类选择器</strong></p>
<p>语法格式</p>
<p><strong>：link{}  设置未点击链接时链接的样式</strong></p>
<p><strong>：visited{} 设置点击链接后链接的样式</strong></p>
<p><strong>：hover{}  设置鼠标移动到链接时的样式</strong></p>
<p><strong>：active{}  设置鼠标点击链接且不松开时的样式</strong></p>
<p>注意：必须按照以上<strong>lvha</strong>的顺序</p>
<p>一般工作不需要用到active和visited，所以有以下便捷写法*/</p>
<p>​        a{color:gray;}a:hover{color:red;}</p>
<p><strong>结构伪类选择器(原理:先找到XX元素的父元素，再找这个父元素的第指定个元素，如果不与xx元素相同则无视。即是相对于父元素的结构伪类）</strong></p>
<p><strong>n是从0到指定的元素个数</strong></p>
<p>xx:first-child{}     选择xx元素中的第一个子元素</p>
<p>Xx:last-child{}     选择xx元素中的最后一个子元素</p>
<p>Xx：nth-child（y）{}  选择xx元素中的第y个子元素</p>
<p>Xx：nth-child（n）{}  选择所有子元素</p>
<p>Xx：nth-child（even）{} 选择所有第偶数个子元素</p>
<p>Xx：nth-child（odd）{} 选择所有第奇数个子元素</p>
<p>Xx：nth-child（2n）{} 选择所有第偶数个子元素</p>
<p>Xx：nth-child（2n+1）{}   选择所有第奇数个子元素</p>
<p>Xx：nth-last-child（）{} 与上面相同，但是是倒数</p>
<p>xx：nth-child（-n+y）{} 选择前y个</p>
<p>xx:nth-of-type(n){}  只认定xx元素同级元素中所有xx元素。即所有xx元素中的第n个</p>
<p>xx:nth-last-of-type （）{} 倒数</p>
<p><strong>兄弟伪类选择器</strong></p>
<p><strong>xx + yy {}  加号代表与xx元素相邻的yy元素 必须是相邻的</strong></p>
<p><strong>xx ~ yy{}波浪号代表满足条件的所有xx的兄弟元素</strong></p>
<p><strong>伪元素选择器</strong></p>
<p>X：：first-letter{}  选中x标签中文档的第一个字</p>
<p>X：：first-line{} 选中x标签中文档的第一行</p>
<p>X：：selection{} 使选中的文字发生实时变化（只能改变显示样式不能改变内容大小）</p>
<p>X：：before{content：”xx”;}在x文档的开头添加文字xx</p>
<p>X：：after{content:”xx”；}在x文档的结尾添加文字XX</p>
<p><strong>伪元素的本质</strong></p>
<p><strong>伪元素本质为行内元素，改为块级元素(或者浮动、定位）后可以设置宽高，伪元素不占位置。设置：before和：after时必须设置content属性，否则伪元素不起作用</strong></p>
<p><strong>后代选择器</strong></p>
<p>父标签 子孙标签{}</p>
<p><strong>可以选择父标签内的所有对应子标签、孙标签、重孙标签。。。</strong></p>
<p><strong>子元素选择器</strong></p>
<p>父标签&gt;字标签{}</p>
<p><strong>只能选择父标签的亲生儿子标签。</strong></p>
<p><strong>属性选择器</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C2737e925ba48495f9340f235352dd41f%5Cimage1.jpeg" alt="img"></p>
<p>target样式：可以为锚点目标元素添加样式，当目标元素被触发为当前锚点链接的目标时，调用此样式</p>
<p>语法 目标链接：target {样式;}</p>
<p><strong>颜色</strong></p>
<p><strong>CSS颜色三种表达方式</strong></p>
<p><strong>1.直接用名字表示 color：red</strong></p>
<p><strong>2.用16进制代码表示  color：#ffb100</strong></p>
<p><strong>3.用rgb代码表示 rgb（192，255，252） 分别代表红绿蓝，16进制数</strong></p>
<p><strong>4.rgba（x，x，x，x）最后一个数值可以设置半透明度</strong></p>
<p><strong>5.hsl（颜色，饱和度，亮度）；  颜色0<del>360  饱和度、亮度0%</del>100%</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C985e489566514fd6852b5a3811eb1088%5Color.png" alt="img"></p>
<p><strong>行高对齐和首行缩进</strong></p>
<p>行间距：line-height：xxpx;</p>
<p>首行缩进  text-indent：xxem；</p>
<p>字间距:letter-spacing</p>
<p><strong>文字阴影</strong></p>
<p>Text-shadow:水平位置(px) 垂直位置(px) 模糊距离(px) 阴影颜色(rgba);</p>
<p><strong>CSS书写规范</strong></p>
<p><strong>1.选择器与花括号之间必有空格</strong></p>
<p><strong>2.属性名与冒号之间不允许有空格，冒号后必须有空格</strong></p>
<p><strong>3.属性值后必须加分号</strong></p>
<p><strong>4.当选择器有多个并行标签时，应上下逗号分开</strong></p>
<p><strong>5.选择器的嵌套尽量不超三层</strong> </p>
<p><strong>6.不同属性应另起一行</strong></p>
<p><strong>CSS样式表</strong></p>
<p><strong>内部样式表</strong></p>
<head>

<style type=’’text/CSS’’>

选择器 {属性1：属性值1；属性2：属性值2；属性3：属性值3；}

</style>

<meta name="generator" content="Hexo 4.2.0"></head>

<p><strong>行内样式表</strong></p>
<p>&lt;标签名 style=’’属性1：属性值1；属性2：属性值2；属性3：属性值3；”&gt;</p>
<p><strong>外部样式表</strong></p>
<head>

<link href=’’css的路径’’ type=’’text/css’’ rel=’’stylesheet’’ />   是个单标签

</head>



<p>总结：推荐使用外部样式表</p>
<p><strong>标签显示类型</strong></p>
<p><strong>块级标签</strong></p>
<p>如<h1> <p> <div> <ul> <ol> <li>等</p>
<p>块级元素特点：</p>
<ol>
<li>总是从新行开始</li>
<li>高度、行高、外边距以及内边距都可以控制</li>
<li>宽度默认是容器的100%</li>
<li>可以容纳内联元素和其他块元素</li>
</ol>
<p><strong>行内元素</strong></p>
<p>如<a> <strong><b><em><i><del><s><ins><u><span>等</p>
<p>特点：</p>
<ol>
<li>和相邻行内元素在一行上</li>
<li>高宽无效，但水平方向的padding和maigin可以设置，垂直方向的无效</li>
<li>默认宽度是它本身内容的宽度</li>
<li>行内元素只能容纳文本或其他行内元素</li>
</ol>
<p>注意：文字标签里不能放块级元素。链接里不能再放链接</p>
<p><strong>行内块元素</strong></p>
<p>如<img/><input/><td>等</p>
<p>特点：</p>
<ol>
<li>和相邻行内元素在一行上，但是之间会有空白缝隙</li>
<li>默认宽度就是它本身内容的宽度</li>
<li>高度，行高，外边距以及内边距都可以控制</li>
</ol>
<p><strong>背景图设置</strong></p>
<p>Background-img:url（）；背景图地址</p>
<p>Background-color:；设置背景颜色</p>
<p>Background-repeat:；设置平铺方式  有no-repeat、repeat-x、repeat-y、space、round选项，分别对应全平铺，x轴方向平铺，y轴方向平铺,图片不缩放并增加空隙后平铺，图片缩放后使其紧贴平铺 </p>
<p><strong>设置背景图位置</strong></p>
<p>Background-position：x轴方向像素 y轴方向像素；</p>
<p>Background-posiiton：方位词 方位词；（无先后顺序之分）top bottom left right center</p>
<p>Background-position：方位词+y像素（x像素+方位词）；</p>
<p><strong>背景图平铺开始位置</strong></p>
<p>background-origin:border-box,padding-box,content-box(即从border、padding、content开始平铺）</p>
<p>bcakground-clip:border-box,padding-box,content-box(即分别只显示border及以内、padding及以内、content的内容）</p>
<p><strong>背景附着</strong></p>
<p>Background-attachment：scroll（fixed） 前者为默认随对象内容滚动，后者为背景图像固定 local</p>
<p>背景简写：background：color  url 平铺方式 滚动方式 位置;（尽量采用此顺序）</p>
<p>背景半透明：在颜色设置中采用rgba（x，x，x，0.x）最后为透明度数值</p>
<p><strong>背景缩放：</strong></p>
<p>Background-size：xxpx xxpx；   </p>
<p>Background-size：xx% xx%；</p>
<p>Background-size：contain；    自动调整缩放比例保证图片完整显示</p>
<p>Background-size：cover；    自动调整缩放比例保证图片填充满背景区域</p>
<p><strong>多背景图片</strong></p>
<p>Background-image：url（），url（）；</p>
<p>Background：url（xxxx）……，url（xxx） ……；   不同图片以逗号隔开</p>
<p><strong>凹陷文字效果</strong></p>
<p>突出效果：</p>
<p>div:first-child{</p>
<p>​                text-shadow: 2px 2px 2px #000,</p>
<p>​                             -1px -1px 1px #fff;</p>
<p>​        }</p>
<p>凹陷效果：</p>
<p>​        div:last-child{</p>
<p>​                text-shadow: 1px 1px 1px #fff,</p>
<p>​                             -2px -2px 2px #000;</p>
<p>​        }</p>
<p>小技巧 将行距设置为盒子高度即可使文本垂直居中</p>
<p>Text-decoration：none 不设置下划线</p>
<p>Text-decoration：underline 设置下划线</p>
<p>Text-decoration：overline 设置上划线</p>
<p>Text-decoration：line-through 设置穿过文本的一条线</p>
<p><strong>CSS三大特性:层叠性、继承性、优先级</strong></p>
<p><strong>层叠性</strong></p>
<p>当同个标签设置样式属性不同值出现冲突时，则依照就近原则以最后的样式属性为准。</p>
<p><strong>继承性</strong></p>
<p>子元素能继承父元素的样式</p>
<p><strong>优先级</strong></p>
<p><strong>CSS Speciality 权重值：</strong></p>
<p><strong>继承或*的贡献值   0,0,0,0</strong></p>
<p><strong>每个元素标签的贡献值 0,0,0,1</strong></p>
<p><strong>类、伪类、元素选择器的贡献值 0,0,1,0</strong></p>
<p><strong>Id选择器的贡献值 0,1,0,0</strong></p>
<p><strong>行内样式贡献值 1,0,0,0</strong></p>
<p><strong>！Important的贡献值 ∞无穷大</strong></p>
<p><strong>注意：</strong></p>
<p><strong>权重可以叠加 如：div ul li 的贡献值为0,0,0,3</strong></p>
<p><strong>数位之间没有进制</strong></p>
<p><strong>继承的权重为0</strong></p>
<p>总结优先级：</p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Ca87bcf2141da4adab14f5edcd014215f%5Cimage2.jpeg" alt="img"></p>
<p><strong>CSS盒子模型</strong></p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C6b378a9d525d45a583645aba74c937c7%5Cimage3.jpeg" alt="img"></p>
<p><strong>盒子边框</strong></p>
<p>Border-color：  设置边框颜色</p>
<p>Border-width： 设置边框厚度</p>
<p>Border-style： 设置边框类型</p>
<p>Style属性值有： </p>
<ol>
<li>实线solid</li>
<li>虚线dashed</li>
<li>点线dotted</li>
<li>双实现double</li>
</ol>
<p><strong>不同方向边框的写法</strong></p>
<p>border-top（left、right、bottom）-width（color、style）</p>
<p><strong>边框综合写法</strong></p>
<p>Border：width style color</p>
<p><strong>合并细线表格</strong></p>
<p>Border-collapse：collapse</p>
<p><strong>圆角矩形</strong></p>
<p>Border-radius:xxpx(xx%)     设置四个角</p>
<p>Border-radius:xx xx     设置左上右下  左下右上</p>
<p>Border-radius：XX XX XX 设置左上 左下右上 右下</p>
<p>Border-radius：xx xx xx xx   左上 右上 右下 左下</p>
<p>border-radius:xx/xx     设置每个角的水平/垂直方向</p>
<p>border-方位词-方位词-radius：xxpx； 如broder-top-right-radius</p>
<p>border-radius：x1 x3 x5 x7/x2 x4 x6 x8;    x1x2为左上 x3x4右上 以此类推    </p>
<p><strong>边框图片</strong></p>
<p>border-image-source：url（）；</p>
<p>border-image-slice：xx fill； 图片切片，不需加单位,即将图片四个边xx像素的宽度作为边框 fill则是将整个图片填充 </p>
<p>border-image-width:xxpx 设置边框背景图宽度 但是不影响内容放置</p>
<p>border-image-outset:0  边框扩展，一般为0</p>
<p>border-image-repeat:repeat/round (前者直接平铺 后者缩放后平铺）</p>
<p>简写 border-image:source slice /width/outset repeat;</p>
<p><strong>盒子内边距</strong></p>
<p>Padding：xx     设置四个边距</p>
<p>Padding：xx xx    设置上下 左右边距</p>
<p>Padding：xx xx xx   设置 上 左右 下边距</p>
<p>Padding：xx xx xx xx   设置上 右 下 左 边距</p>
<p><strong>Firework工具 滴管查颜色 切片查距离</strong></p>
<p><strong>清除内外边距</strong></p>
<p>* {padding：0；margin：0}</p>
<p><strong>行内元素只有左右内外边距没有上下内外边距，尽量不要给行内元素指定上下内外边距</strong></p>
<p><strong>外边距合并的问题</strong></p>
<p>垂直相邻的块元素，若上面的元素有margin-bottom，下面额块元素有margin-top，则他们之间的外边距之和不是两者相加而是两者较大者。这种现象被称为相邻块元素垂直外边距的合并</p>
<p>解决方法：只设置一个盒子的外边距即可</p>
<p><strong>嵌套块元素的合并</strong></p>
<p>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会子元素的上外边距合并，合并结果为两者中较大者。</p>
<p><strong>解决方法：1.为父元素定义1像素的边距或内边距2.可以为父元素添加overflow：hidden</strong></p>
<p><strong>盒子尺寸计算</strong></p>
<p>外盒尺寸=width（height）+padding+border+margin</p>
<p>内盒尺寸=width(height)+padding+border</p>
<p>注意：</p>
<ol>
<li>width和height对行内元素无效</li>
<li>要考虑上下两个盒子的外边距合并</li>
<li>若盒子没有指定高度或宽度（或继承了父元素的高度或宽度），则padding不会影响整体高度或宽度</li>
</ol>
<p><strong>盒子模型布局稳定性</strong></p>
<p><strong>使用优先级：width&gt;padding&gt;margin</strong></p>
<p>原因：</p>
<p>1.margin会有外边距合并，还有ie6下面margin加倍的bug</p>
<p>2.padding会影响盒子大小，需要进行加减计算</p>
<p>3.Width没有问题，常用宽度剩余法 高度剩余法来做</p>
<p><strong>CSS3盒模型</strong></p>
<p><strong>1.box-sizing：content-box</strong>   </p>
<p>盒子大小为width+padding+border 为默认值</p>
<p><strong>2.box-sizing：border-box</strong>  </p>
<p>盒子大小为width 即padding和border包含到了width里面 如果为这个值，则设置padding时不用重新计算</p>
<p><strong>盒子阴影</strong></p>
<p><strong>box-shadow: 0px 10px 10px 10px rgba(0 ,0 ,0 , .3)  inset    分别设置 水平距离 垂直距离 模糊距离 阴影大小 颜色 内阴影/外阴影</strong></p>
<p><strong>文档流</strong></p>
<p><strong>类型</strong></p>
<p><strong>1.普通流：网页内标签正常地从上到下从左到右的排序，如块级元素独占一行，行内元素会依照顺序依次前后排列</strong></p>
<p><strong>2.浮动</strong></p>
<p><strong>3.定位</strong></p>
<p><strong>浮动：指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。</strong></p>
<p>语法：选择器{float：属性值；}</p>
<p>属性值：left、right、none</p>
<p>使用浮动首先要添加标准流父盒，从而防止布局失真</p>
<p>浮动特性</p>
<ol>
<li>父盒内的盒子设置浮动后会就近对齐父盒子，但不会遮盖padding和margin</li>
<li>兄弟盒子中第一个盒子如果浮动，第二个盒子设置浮动后会与其顶部对齐。若第一个盒子不浮动，第二个盒子设置浮动后顶部会与其底部对齐</li>
</ol>
<p>元素（包括块级和行内）添加浮动后，都会具有行内块元素的特性</p>
<p>总结：float==&gt;浮漏特</p>
<p>浮：加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面</p>
<p>漏：加了浮动的盒子，不占位置的，他浮起来了，他原来的位置漏给了标准流的盒子</p>
<p>特：特别注意要和标准流父级搭配使用。</p>
<p><strong>清除浮动</strong></p>
<p><strong>在一般情况下，考虑到子盒子的内容变化，父盒子都不方便设置高度。子盒子没有浮动时会自动撑开父盒子。如果子盒子浮动，则父盒子高度会变为0，导致其他盒子占据位置。</strong></p>
<p><strong>清除浮动就是解决没有设置高度的父盒子在子盒子浮动后高度变为0的现象</strong></p>
<p><strong>解决方法</strong></p>
<p><strong>1.在父盒子中添加overflow：hidden；</strong></p>
<p><strong>2.浮动盒子后添加空标签，且将该标签的clear属性值设置为both</strong></p>
<p><strong>.clear {</strong></p>
<p>​            <strong>clear: both;**</strong>}**  <strong>清除浮动的影响</strong></p>
<p><strong>3.用after伪元素清除浮动（推荐）</strong></p>
<p><strong>父盒子类名添加 clearfix</strong></p>
<p><strong>.clearfix:after {</strong></p>
<p>​            <strong>content: ‘.’;</strong></p>
<p>​            <strong>display: block;</strong></p>
<p>​            <strong>height: 0;</strong></p>
<p>​            <strong>visibility:hidden;</strong></p>
<p>​            <strong>clear: both;</strong> </p>
<p>​        <strong>}</strong></p>
<p><strong>4.用before和after伪元素清除浮动（推荐）</strong></p>
<p><strong>父盒子类名添加clearfix</strong></p>
<p><strong>.clearfix:before,.clearfix:after {display:table;content:**</strong>’** <strong>‘**</strong>;}**</p>
<p><strong>.clearfix:after {clear:both;}</strong></p>
<p><strong>.clearfix {*zoom:1;}</strong></p>
<p><strong>定位（包括定位模式和边偏移）</strong></p>
<p><strong>边偏移</strong></p>
<p>Top bottom left right</p>
<p><strong>定位模式</strong></p>
<p><strong>语法：</strong></p>
<p><strong>Position：{属性值；}</strong></p>
<p><strong>属性值：</strong></p>
<ol>
<li><strong>静态定位static：</strong></li>
<li><strong>相对定位relative：</strong></li>
<li><strong>绝对定位absolute</strong></li>
<li><strong>固定定位fixed</strong></li>
</ol>
<p><strong>Static定位：</strong></p>
<p>默认，该定位下无法使用边偏移属性</p>
<p><strong>Relative定位：</strong></p>
<p>定位后可通过边偏移改变位置，是以自身左上角为基准。不脱标，依旧是标准流，原先位置保留</p>
<p><strong>Absolute定位：</strong></p>
<p>可通过边偏移改变位置，完全脱标不占位置。</p>
<p>子盒子设置为absolute后，父盒子必须定位为任何定位类型，子盒子才能以父盒子为基准设置边偏移改变位置，否则会乱跑</p>
<p><strong>子绝父相：一般子盒子设置为绝对定位后，父盒子要设置为相对定位较好</strong></p>
<p><strong>水平/垂直居中：盒子设置绝对定位后，margin中的auto无效（具体数值有效）</strong></p>
<p>要居中一般是以：1首先left50%2.然后走外边距负的一半值即可</p>
<p>如：left：50%；margin-left：-xxpx；</p>
<p>Top：50%；margin-top：-xxpx；</p>
<p>或者 left：父盒子宽度一半减去子盒子宽度一半；top：父盒子高度一半减去子盒子高度一半</p>
<p><strong>Fixed定位</strong></p>
<ol>
<li>固定定位的元素跟父亲没有任何关系，只认浏览器</li>
<li>完全脱标,不占位置,不随着滚动条移动</li>
</ol>
<p><strong>叠加次序</strong></p>
<ol>
<li>index:正整数、负整数、0</li>
</ol>
<p>注意</p>
<p>1.index默认属性值为0，取值越大，定位元素在层叠元素中越居上</p>
<p>2.如果取值相同，则按顺序后来居上</p>
<p>3.后面数字不能家单位</p>
<p><strong>4.**</strong>只有相对定位绝对定位固定定位有这个属性。**</p>
<p><strong>定位总结</strong> </p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Ce327bca0e0934129879d40ae19cfd22c%5Cimage4.jpeg" alt="img"></p>
<p><strong>固定绝对定位模式转换</strong></p>
<p>跟浮动一样,元素添加了绝对定位和固定定位之后,元素都会变成行内块模式</p>
<p>也就是；如果行内元素添加了绝对定位和固定定位后,可以不用转换模式,直接添加高度宽度。</p>
<p><strong>Display和visibility的使用</strong></p>
<p>Display设置或检索对象是否及如何显示</p>
<p>Display：none 隐藏对象</p>
<p>Display：block除了转换为块级元素之外还有显示元素的意思</p>
<p>特点：隐藏之后，不再保留位置</p>
<p>Visibility</p>
<p>设置或检索是否显示对象</p>
<p>Visible：对象可视</p>
<p>Hidden：对象隐藏</p>
<p>特点:隐藏之后,继续保留原有位置</p>
<p><strong>Overflow溢出</strong></p>
<p>属性值</p>
<p>Visible:不剪切内容也不添加滚动条 （默认）</p>
<p>Auto：超出自动显示滚动条,不超出不显示滚动条</p>
<p>Hidden：不显示超出对象内容的尺寸,超出的部分隐藏掉</p>
<p>Scroll：不管超出内容否,总是显示滚动条</p>
<p><strong>CSS高级技巧</strong></p>
<p><strong>鼠标样式</strong></p>
<p>cursor: default;    小白（默认） </p>
<p>cursor: pointer;    小手</p>
<p>cursor: text;     文本    </p>
<p>cursor: move;    移动</p>
<p><strong>取消轮廓线</strong></p>
<p>语法：</p>
<p>Outline : width style color;</p>
<p>一般为none</p>
<p><strong>防止拖拽文本</strong></p>
<p>textarea {resize: none;} </p>
<p><strong>行内块和文字对齐（一些低版本浏览器中盒子内的图片可能底部出现缝隙）</strong></p>
<p>Vertical-align:实现行内元素和行内块元素的对齐，对于块级元素无效</p>
<p>属性值包括 top、middle、bottom、baseline（默认）</p>
<p>一般选用middle </p>
<p><strong>去除图片底侧缝隙</strong></p>
<ol>
<li>将图片转为块级元素 display：block</li>
<li>将图片顶部对齐或者中线对齐  vertical-align：top（middle）  </li>
</ol>
<p><strong>Word-break用法</strong></p>
<p>Word-break：normal     默认方式</p>
<p>Word-break：break-all  允许单词中换行</p>
<p>Word-break：keep-all 只能在半角空格或连字符处换行</p>
<p><strong>White-space用法</strong></p>
<p>White-space：normal  默认处理方式    </p>
<p>White-space：nowrap 强制在同一行显示所有文本，直到1文本结束或遭遇br才换行</p>
<p><strong>Text-overflow使用</strong></p>
<p>Text-overflow:clip   不显示省略标记,而是简单的裁切</p>
<p>Text-overflow:ellipsis 当对象文本溢出时显示省略标记</p>
<p><strong>注意：**</strong>必须先使用white-space：nowrap和overflow：hidden两个属性后才能使用这个**</p>
<p><strong>精灵技术</strong></p>
<p>即将所有背景图通过一张图来显示</p>
<p>先设置对应元素的宽高，再设置background-position,注意此处应为负值</p>
<p><strong>字体图标</strong></p>
<p>网站：icomoon.io</p>
<p><strong>将下载后的icomoon文件夹中的font文件夹放到与html文件同个文件夹中，然后声明，声明后打开icomoon文件夹中的html文件复制小空格到目标元素中，再设置font-family。</strong></p>
<p>追加字体文件要利用icomoon文件夹中的selection文件</p>
<p><strong>滑动门技术</strong></p>
<p>固定语法</p>
<p>a里面包含span</p>
<p>不能设置宽度</p>
<p>A负责左边框，span负责右边框且背景图位置应设置为right</p>
<p>记得转换为块元素或行内块元素</p>
<p><strong>2D效果</strong></p>
<p><strong>过渡效果</strong></p>
<p>Transition：变化的属性 过渡时间 时间曲线 开始时间</p>
<p>变化的属性：所有属性过渡效果一样时可以用all代表，不相同则需逗号隔开重写</p>
<p>过渡时间：s为单位，必须写，包括0</p>
<p>时间曲线：linear匀速 ease变慢 ease-in 加速  ease-out减速 ease-in-out先加速后减速</p>
<p>开始时间：s为单位，必写</p>
<p>Transition要写在变化的元素内而不是元素的hover内</p>
<p><strong>移动</strong></p>
<p>Transform:translate（xxpx xxpx）； 第一个为x轴方向移动距离,第2个为y轴方向移动距离</p>
<p>盒子居中新方法：left、top（浏览器一般长度） 然后 transform：translate（-盒子一半宽度 -盒子一半长度）</p>
<p>translate如果用百分比则是以元素本身长宽为基准</p>
<p>translateX：沿x轴移动</p>
<p>translateY：沿y轴移动</p>
<p>translateZ：沿Z轴移动</p>
<p><strong>缩放</strong></p>
<p>Transform:scale（任何正整数） 0-0.99是缩小 大于1是放大</p>
<p><strong>旋转</strong></p>
<p>Transform：rotate（xxdeg）； deg是度数单位 </p>
<p>改变旋转中心</p>
<p>Transform-origin：xxpx xxpx（方位词 方位词）；（写在变化元素标签内，而不是动作内）</p>
<p>Transform-style  指定嵌套元素如何在3d空间中呈现</p>
<p>属性值 flat（默认值）：所有子元素在2D平面呈现</p>
<p>Preserve-3d：表示所有子元素在3D空间中呈现</p>
<p>translate3d(x方向的偏移，y方向的偏移，z方向的偏移）</p>
<p>scale3d（x方向的缩放，y方向的缩放，z方向的缩放）</p>
<p>rotate3d（x方向向量，y方向向量，z方向向量，旋转角度） </p>
<p><strong>倾斜</strong></p>
<p>Transform：skew（xxdeg xxdeg）； 第一个为x轴方向倾斜,正值向右负值向左</p>
<p>第二个为y轴倾斜方向,正值向上负值向下</p>
<p><strong>Web坐标轴</strong></p>
<p>左右是x轴负、正方向</p>
<p>上下是y轴负、正方向</p>
<p>朝外朝内是z轴正负方向</p>
<p>rotateX：绕x轴旋转</p>
<p>rotateY：绕y轴旋转</p>
<p>rotateZ：绕z轴旋转</p>
<p><strong>透视属性</strong></p>
<p>Perspective：xxpx;</p>
<p>Persperctive 代表着观察者眼睛到屏幕的距离,赋予3d效果</p>
<p>数值越小透视效果越好 数值越大透视效果越差</p>
<p>perspective-origin:xxpx  xxpx；设置观察的角度</p>
<p><strong>动画</strong></p>
<p><strong>引用动画</strong></p>
<p><strong>Animation:动画名称 持续时间 时间曲线 启动时间 播放次数 是否反方向</strong></p>
<p>animation-fill-mode设置动画结时的状态</p>
<p>属性值：forward 动画结束时保持状态 backward 动画结束时不保持状态，在设置了动画延时的前提下，如果动画有初始状态，那么会立刻进行到初始状态  both：会保留动画结束的初始状态,在设置了动画延时的前提下，如果动画有初始状态，那么会立刻进行到初始状态 </p>
<p>animation-play-state:running(paused)设置动画播放状态</p>
<p><strong>动画持续时间还有个属性值为steps（n）  就是将动画分为n步执行</strong></p>
<p><strong>定义动画</strong></p>
<p>@keyframes 动画名称 {from{}   to{}       }或者 {百分数{} 百分数{} 百分数{}}</p>
<p>时间曲线同transition</p>
<p>播放次数 infinite无限次播放</p>
<p>方向：</p>
<ol>
<li>normal 正常方向</li>
<li>Reverse 反方向</li>
<li>Alternate 先正常后反方向，不断交替</li>
<li>Alternate-reverse： 先反方向再正常，不断交替</li>
</ol>
<p><strong>多列布局</strong></p>
<p>column-count:设置分成的列数</p>
<p>column-rule：宽度 线条样式 颜色；     设置列之间的样式</p>
<p>coulumn-gap：xxpx；    设置列之间的距离</p>
<p>column-width：设置每一列的宽度  如果设置宽度比当前列数所默认的宽度小，则不改变，如果比较大，则取其值并铺满整个浏览器；</p>
<p>column-span：设置某个元素跨越的列数，只有1和all两个选项；</p>
<p><strong>BFC（块级格式化上下文）：是一个独立的渲染区域,只有Block-level box参与,它规定了内部的Block-Level Box如何布局，并且与这个区域外部毫不相干</strong></p>
<p><strong>具有BFC条件的元素模式：block、list-item、table</strong></p>
<p>触发BFC的属性：</p>
<ol>
<li>float属性不为none</li>
<li>Position为absolute或fixed</li>
<li>Display为inline-block、table-cell、table-caption、flex、inline-flex</li>
<li>Overflow不为visible</li>
</ol>
<p><strong>BFC特性</strong></p>
<ol>
<li>BFC中，盒子从顶端垂直的一个接一个排列</li>
<li>属于同一个BFC的两个相邻盒子的margin会发生重叠   </li>
<li>BFC中，每一个盒子的左外边缘会触碰到容器的左边缘</li>
<li>BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘   （用于产生浮动盒子旁边的自适应盒子）</li>
<li>计算BFC的高度时，自然也会检测浮动的盒子高度  （用于清除浮动）</li>
</ol>
<p><strong>作用</strong></p>
<ol>
<li>清除浮动</li>
</ol>
<p>给父盒子激活BFC就可以</p>
<ol>
<li>解决外边距合并</li>
</ol>
<p>用另一个BFC盒子将两个盒子中的一个包起来，即可解决</p>
<ol>
<li>产生浮动盒子旁的自适应盒子</li>
</ol>
<p>将新盒子激活BFC，就不会跑到浮动盒子下面，而是与其紧贴</p>
<p><strong>渐进增强：构建网站时先满足低版本再考虑高版本</strong></p>
<p><strong>优雅降级：与上者相反</strong></p>
<p><strong>浏览器前缀</strong></p>
<p>-webkit-：chrome ，safari，android，browser</p>
<p>-moz-：firefox</p>
<p>-o-：opera</p>
<p>-ms-：ie，edge</p>
<p>-khtml-：konqueror</p>
<p><strong>背景颜色渐变（因为兼容性问题严重，所以需要加浏览器前缀）</strong></p>
<p>线性渐变：</p>
<p>background:-浏览器前缀- linear-gradient(渐变起始位置， 起始颜色， 结束颜色)；</p>
<p>background:-浏览器前缀- linear-gradient(渐变起始位置， 起始颜色 百分比， 结束颜色 百分比)；用渐变起始位置就需要加浏览器前缀</p>
<p>background:linear-gradient（point/angle,颜色 位置，颜色 位置 颜色 位置….）</p>
<p>point：to left(从右到左）,to right,to top,to bottom（默认值）</p>
<p>angle：对应上面为270deg，90deg，0deg，180deg</p>
<p>用point/angle就不用加浏览器前缀</p>
<p>径向渐变</p>
<p>background:radial-gradient(形状 大小 发散位置，颜色 位置，颜色 位置，颜色 位置，。。。）；</p>
<p>形状：默认为ellipse（即自动适配当前形状），circle（圆形）</p>
<p>大小：closest-corner、closest-side、farthest-corner、farthese-side</p>
<p>发散位置：at xxpx xxpx或at 方位词 方位词（默认在正中心）</p>
<p>重复渐变</p>
<p>repeating-radial(linear)-gradient:属性值同上</p>
<p><strong>三大标签优化</strong></p>
<p><strong>Title</strong> </p>
<title>标题</title>

<p>长度：google（35中文） baidu（28个中文）</p>
<p>最先出现的词语的权重越高</p>
<p>建议：首页标题：网站名（产品名）-网站的介绍</p>
<p><strong>Description</strong></p>
<Meta name=“description” content=“内容” />

<p>搜索结构的部分摘要，即简要说明我们的网站是做什么的</p>
<p>注意：不要超过120个汉字，用英文逗号</p>
<p><strong>Keyword</strong></p>
<Meta name=“keyword” content=“内容” />

<p>页面关键词，搜索引擎关注点之一，限制在6-8个关键词左右</p>
<p>布局时为了防止浏览器缩小时两个元素重叠，可以将两个元素先定位到相反的位置，然后再用translate移动到目的位置</p>
<p>实现打字动画效果，可以先将完整文字图片的宽度改为0，再利用trasnform将宽度改回来，并用steps分步执行</p>
]]></content>
  </entry>
  <entry>
    <title>html</title>
    <url>/2020/02/03/html/</url>
    <content><![CDATA[<p>HTML：超文本标签语言</p>
<p>h5并不是新语言，而是html语言的第五个版本</p>
<p>支持：所有主流浏览器都支持h5（chrome，Firefox，safari。。。）。IE9（部分支持）及以上支持h5，但是ie8（完全不支持）及以下不支持h5.</p>
<p>增加了新特性:语义特性，本地存储特性，网页多媒体，二维三维，特效。</p>
<p>HTML骨架:</p>
<html> 根标签/根节点

<pre><code>&lt;head&gt; 用于存放title、meta、base、style、script、link</code></pre><p>​              <title></title>标题标签</p>
<pre><code>&lt;/head&gt;

&lt;body&gt;主体标签

&lt;/body&gt;</code></pre></html>



<p>标签分类:双标签 &lt;标签名&gt;内容&lt;/标签名&gt;</p>
<p>​         单标签 &lt;标签名/&gt; 如换行标签<br /></p>
<p>标签关系</p>
<p>1.嵌套关系：如html是所有标签的父标签、</p>
<p>2.并列关系：如head和body标签</p>
<p>如果两个标签是嵌套关系，子元素最好缩进一个tab的身位。若是并列关系，最好上下对齐。</p>
<p>sublime快速生成html骨架：1.html：5后tab 2.！后tab   *快速生成必备插件：emmet</p>
<!DOCTYPE xxx><p>标签作用：告诉我们使用哪个html版本</p>
<p>如&lt;！DOCTYPE html&gt;说明使用的是h5版本</p>
<p>字符集</p>
<p>utf-8：包含全世界所有国家需要用到的字符</p>
<p>gb2312：简体中文</p>
<p>BIG5：繁体中文</p>
<p>GBK：包含全部中文字符</p>
<p>标签的语义化：指标签的含义</p>
<p>遵循的原则：先确定语义的html，再选合适的CSS</p>
<hr>
<p>HTML标签：</p>
<p>一、排版标签：</p>
<p><strong>1.标题标签：<h1></h1> <h2></h2>  <h3></h3> <h4></h4> <h5></h5></strong> </p>
<p><strong>2.段落标签：<p> 文本内容 </p></strong> </p>
<p><strong>3.水平线标签：<hr />(单标签) 增加一条线 hr=horizon</strong></p>
<p><strong>4.换行标签：<br /> br=break</strong></p>
<p><strong>5.div span标签：网页布局的两个主要盒子  div=division</strong></p>
<p><strong>二、文本格式化标签</strong></p>
<p><strong>1.字体加粗：<strong> </strong></strong></p>
<p><strong>2.字体倾斜：<em> </em></strong> </p>
<p><strong>3.字体加删除线:<del> </del></strong></p>
<p><strong>4.字体加下划线：<ins> </ins></strong></p>
<p>标签属性</p>
<p>基本语法格式：</p>
<p>&lt;标签名 属性1=“属性值” 属性2=“属性值2” …&gt;内容&lt;/标签名&gt;</p>
<p>在上面的语法中，</p>
<ol>
<li>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面</li>
<li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li>
<li>任何标签的属性都有默认值，省略该属性则取默认值</li>
</ol>
<p>采取 键值对 的格式 key=”value”的格式</p>
<ol>
<li>图像标签</li>
</ol>
<p>基本语法格式</p>
<img src=”图像URL(图像路径)” />



<p><img />标记属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>URL</td>
<td>图像的路径</td>
</tr>
<tr>
<td>alt</td>
<td>文本</td>
<td>图像不能显示时的替换文本</td>
</tr>
<tr>
<td>title</td>
<td>文本</td>
<td>鼠标悬停时显示的内容</td>
</tr>
<tr>
<td>width</td>
<td>像素</td>
<td>图像宽度</td>
</tr>
<tr>
<td>height</td>
<td>像素</td>
<td>图像高度</td>
</tr>
<tr>
<td>border</td>
<td>像素</td>
<td>边框宽度</td>
</tr>
</tbody></table>
<p>四、链接标签</p>
<p>基本语法格式：</p>
<p><a href=”跳转目标”  target=”目标窗口的弹出方式”>文本或图像</a></p>
<p>Href用于指定链接目标的url地址，当为标签应用href属性值时，它就具有了超链接的功能</p>
<p>Target用于指定链接页面打开方式，有_self和_blank两种取值，其中self为默认值，blank为在新窗口中打开方式。</p>
<p>即如果想要对元素添加点击链接功能，则需要对其加上链接标签即a标签</p>
<p>注意</p>
<ol>
<li>外部链接 需要添加http://</li>
<li>内部链接 直接链接内部页面名称即可 比如<a href=”index.html”>首页</a></li>
<li>如果没有确定链接目标，通常将链接标签的href属性值定义为”#”，表示该链接暂时为一个空链接</li>
<li>除了文本，图像表格音频视频等都可以添加超链接 如<a href="img标签.html" target="blank"><img src="C:\Users\Administrator\Desktop\炜\photo\职业照小.jpeg"></a></li>
</ol>
<p>锚点定位</p>
<p>&lt;a href=”#id=uu”&gt;xxx</a>  记得添加#和””号！！！！！非常重要！！！！！</p>
<p><strong>&lt;标签名 id=uu&gt; &lt;/标签名&gt;</strong></p>
<p><strong>详例见锚点定位.html</strong></p>
<p><strong>Base标签</strong></p>
<p><strong>在head中添加&lt;base target=**</strong>”<strong><strong>_blank</strong></strong>”** <strong>/&gt; 可实现所有链接都以新窗口打开，同理_blank改为_self则实现所有链接都以自身窗口打开</strong></p>
<p><strong>若想实现其中某个链接以不同方式打开，则对其单独设置target属性即可。</strong></p>
<p>特殊字符代码  都要记得加“&amp;”</p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C82ebc9a4baca484fb7f9cd0477d539a4%5Cimage1.jpeg" alt="img"></p>
<p>重点记住前三个</p>
<p>注释标签</p>
<!--xxx--> 养成注释的习惯！！！！！！！！

<hr>
<p>路径</p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Ce6f5ebdbf91641cc960c2ec462f7cdb6%5Cimage2.png" alt="img"></p>
<p>一般不用绝对路径</p>
<hr>
<p>无序列表：各个列表项之间没有顺序级别之分，是并列的（没有顺序数字前戳）。</p>
<p>基本语法格式：</p>
<ul>

<li>列表项1</li>

<li>列表项2</li>

<li>列表项3</li>

<p>…</p>
</ul>

<p>注意事项：</p>
<p>1.<ul></ul>之间只能嵌套<li></li>，直接在<ul></ul>标签中输入其他标签或者文字的做法是不被允许的。</p>
<p>2.<li></li>之间相当于一个容器,可以容纳所有元素</p>
<p>3.无序列表的样式可让CSS来完成设置</p>
<p>有序列表：带顺序数字前缀的列表</p>
<p>基本语法格式：</p>
<ol>

<li>列表项</li>

<p>….</p>
</ol>

<p>注意事项与无序列表相同</p>
<p>自定义列表(理解即可）：常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。一般用于网页结尾。</p>
<p>基本语法：</p>
<dl>

<dt>名词1</dt>

<dd>名词1解释1</dd>

<dd>名词1解释2</dd>

<p>…</p>
<dt>名词2</dt>

<dd>名词2解释1</dd>

<dd>名词2解释2</dd>

<p>…</p>
</dl>

<hr>
<p>表格创建</p>
<p>基本语法格式：</p>
<table>

<tr>

<td>单元格内的文字</td>

<p>…</p>
</tr>

<p>…</p>
</table>



<p>Table为整体框架</p>
<p>Tr为行数</p>
<p>Td为每一行内的单元格数（没有列的说法）</p>
<p>注意事项：table里只能放tr标签，不能放其他。而td里可以放任何东西。</p>
<p> 表格属性</p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C7c0dd2f545344c858703714d38d9ac0c%5Cimage3.jpeg" alt="img"></p>
<p>表头标签</p>
<p>把表头的<td>换成<th>，会自动加粗居中。</p>
<p>表头结构</p>
<p>表格布局时可分为头部主体和页脚</p>
<thead></thead>:用于定义表格头部

<tbody></tbody>:用于定位表格主体

<p>以上两种都不显示，只是用于布局。</p>
<p>表格标题</p>
<caption>标题</caption> 写在table标签内



<p>合并单元格</p>
<p>跨行合并：rowspan 跨列合并：colspan</p>
<p>合并单元格的思想：将多个内容合并的时候，会有多余的东西，将其删除。例如把3个td合并成一个，就多于2个，需要删除</p>
<p>公式 删除的个数=合并的个数-1</p>
<p>表格不要纠结于外观，是CSS的作用</p>
<hr>
<p>表单</p>
<p>组成：表单控件，提示信息，表单域3个部分构成</p>
<p>input控件（重点）为单标签</p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5Cb8bb4525045b46be8f42a7231e6d90b1%5Cimage4.jpeg" alt="img"></p>
<p>Type中image可以设置按钮为其他图像 <input type="image" src="img/三国.jpg"></p>
<p>File可以用来上传文件 添加multiple属性可以上传多个文件</p>
<p>如果单选框是同一组，那么可以通过name属性来设置为一组，从而限制选择</p>
<p>Value可以改变按钮中的文本</p>
<p>Checked可以设置默认选项 即<input type=”button” checked=”checked” /></p>
<p>Maxlength可以设置其最大输入字符数</p>
<p>H5input新增的type类型</p>
<p><img src="C:%5CUsers%5CWHO%5CAppData%5CLocal%5CYNote%5Cdata%5Cqq84C281D5A87880FDA451FD57E40936A6%5C65e65ee41d4e4897ad55da4abd86fb65%5Cimage5.jpeg" alt="img"></p>
<p>email 用于填写邮箱，填写时必须有@符号，同时包含服务器域名。如不能满足验证，则会阻止当前的数据提交</p>
<p>tel 用于填写号码，不是用来验证，是为了能在移动端打开键盘时打开数字键盘。即限制了用户只能输入数字</p>
<p>url填写网址。只能输入合法的网址，必须包含http：//</p>
<p>number 只能输入数字 其中 max最大值 min最小值 value默认值</p>
<p>新增占位符焦点多选等属性（即input中的属性值）</p>
<p>color 选择颜色</p>
<p>Label标签的使用</p>
<p>若想实现点击文字就可进入文本框，则可用label标签包裹整个表单选项</p>
<p>如：<label>输入账号：<input type="text" /></label> </p>
<p>若有多个输入框，想定位到某个，则对目标框设置id，然后<label for=”id”></label></p>
<p>若想实现大量文本输入，则可用textarea标签</p>
<p>语法：<textarea>请输入留言</textarea></p>
<p>下拉菜单：用select标签</p>
<select>

<p>​        <option  >北京</option></p>
<p>​        <option selected="selected" >上海</option></p>
<p>​        <option >广州</option></p>
<p>​        <option >深圳</option></p>
</select>

<p>其中selected=”selected”代表默认选项</p>
<p>option也可以为单标签，效果一样</p>
<p>表单域：即整个表单框架</p>
<p>基本语法：</p>
<form action=”url地址” method=”提交方式” name=”表单名称”>

<p>各种表单控件</p>
</form>

<p>常用属性：</p>
<p>Action:表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址</p>
<p>Method：用于设置表单数据的提交方式，其取值为get或post</p>
<p>Name：用于指定表单的名称，以区分同一个页面中的多个表单。</p>
<p>注意：每个表单都要有自己的表单域</p>
<hr>
<p>html文档类型和字符集</p>
<p> HTML:sublime输入html：4s</p>
<p>HTML5:sublime输入html：5 或 ！</p>
<p>XHTML:sublime输入html：xt</p>
<p>H5中字符集写法：<meta charset=”UTF-8”></p>
<p>H5常用新标签</p>
<p>Header：定义文档的页眉 头部</p>
<p>Nav：定义导航链接的部分</p>
<p>Footer：定义文档或节的页脚 底部</p>
<p>Article：定义文章</p>
<p>Section：定义文档中的节</p>
<p>Aside：定义其所处内容之外的内容 侧边</p>
<p>Datalist：标签定义选项列表，请与input元素配合使用该元素</p>
<p>Fieldset:可将表单内的相关元素分组，打包</p>
<p>Datalist用法</p>
<p>通过设置id并在input中的list属性链接这个id，从而达到智能显示的效果</p>
<p><input type="text" value="输入明星" list="star">     <!-- input里面用list --></p>
<p><datalist id="star">  <!-- datalist里面用id实现和input的链接 --></p>
<p>​        <option >刘德华</option></p>
<p>​        <option >郭富城</option></p>
<p>​        <option >黎明</option></p>
<p>​        <option >张学友</option></p>
<p>​        <option >叼你妈</option></p>
<p>​        <option >臭傻逼</option></p>
<p>​        <option >曹尼玛</option></p>
<p>​        <option >吃屎吧</option></p>
</datalist>

<p>datalist与selection的区别:前者不仅可以选择，还可以输入。</p>
<p>datalist弊端：在不同浏览器的显示不同，少用</p>
<p>如果与之连接的input type值为url，则其value值必须添加http://</p>
<p>Fieldset用法：</p>
<p>与legend搭配使用，legend包含在fieldset里面负责写标题。例：</p>
<fieldset>

<p>​        <legend>用户登录</legend>   <!-- 标题 --></p>
<p>​        用户名：<input type="text"> <br /></p>
<p>​        密　　码：<input type="password"></p>
</fieldset> 



<p>常用属性值</p>
<p>Placeholder 可实现用户输入时里面的文字消失，删除所有文字，自动返回</p>
<p>Autofocus：实现打开网页时，光标自动定位到其所在表单</p>
<p>Autocomplete：实现自动记录表单内容，再次输入时可智能提示</p>
<p>用法：用户名：<input type="text" autocomplete="on" name="username"></p>
<p>​                <input type="submit"></p>
<p>注意：必须要有提交按钮。其次表单必须要有名字。</p>
<p>required：要求必须输入</p>
<p>pattern:正则表达式验证</p>
<p>multiple 实现上传填写多个东西</p>
<p>form：指定某个表单id，再将当前表单的form属性值设置为与其id相同。在将来指定id号的表单进行数据提交的时候，也会将当前表单元素的数据进行提交</p>
<p>————————————————————————————————————————————</p>
<p>多媒体标签</p>
<p>引用网上的视频：embed</p>
<p>引用本地视频：video 三种格式：mp4、ogg、wmv</p>
<p>引用本地音频：audio 三种格式：mp3、ogg、wav</p>
<p>常用属性 ：autoplay控制自动播放  controls：添加进度条等控制元素</p>
<p>Loop：x 循环播放x次 poster：设置视频封面</p>
<p>​    <!-- 从上往下一个个尝试 --></p>
<pre><code>&lt;video controls&gt;</code></pre><p>​        <source src="xx.mp4"></p>
<p>​        <source src="xx.flv"></p>
<p>​    </video></p>
<p>———————————————————————————————————————————</p>
<!-- 解决低版本浏览器新标签不兼容的措施 -->

<p>​    <!-- 1.通过创建新标签并转化标签模式 --></p>
<p>​    &lt;!– <script></p>
<p>​        document.createElement("名字")   默认为行级元素</p>
<p>​    </script> –&gt;</p>
<p>​    <!-- 2.通过引入第三方插件 --></p>
<pre><code>&lt;script src=&quot;../html5shiv.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>其他标签</p>
<p>keygen 实现加密 产生私钥和公钥，私钥客户端对信息进行二次加密后与公钥一起发给服务器，服务器再通过公钥对其解密</p>
<p>output输出信息</p>
]]></content>
  </entry>
  <entry>
    <title>如何创建hexo博客</title>
    <url>/2020/02/03/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="如何创建hexo博客"><a href="#如何创建hexo博客" class="headerlink" title="如何创建hexo博客"></a>如何创建hexo博客</h1><p>1、下载node</p>
<p><a href="http://nodejs.cn" target="_blank" rel="noopener">http://nodejs.cn</a></p>
<p>2、安装淘宝npm（cnpm）</p>
<p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
<p>3、下载hexo博客框架</p>
<p>cnpm  install -g hexo-cli</p>
<p>4、博客初始化</p>
<p>hexo init</p>
<p>5、启动博客</p>
<p> hexo s</p>
<p>可以通过   <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>  进行访问</p>
<p>6、创建我的第一篇博客</p>
<p> hexo n “我的第一篇博客”</p>
<p>7、下载插件，用来部署到github上</p>
<p>cnpm install –save hexo-deployer-git</p>
<p>8、在github上创建一个仓库</p>
<p><img src="Y:%5Chexo%5Cpic%5Ca.png" alt=""></p>
<p>如图，第一个名称 Mikasayooooo 必须与仓库所有者 Mikasayooooo 相同</p>
<p>9、hexo根目录下的   有个_config.yml, 在最后面 修改里面的  deploy  配置项</p>
<p><img src="Y:%5Chexo%5Cpic%5Cb.png" alt=""></p>
<p>如图，repo 里的修改为自己的github地址</p>
<p>10、部署到github上</p>
<p>hexo d</p>
<p>刷新github，就会发现github上多了博客的一些内容</p>
<p>11、运行  hexo s ，就能通过github地址来进行访问</p>
<p><img src="Y:%5Chexo%5Cpic%5Cc.png" alt=""></p>
<p>12、博客主体太丑</p>
<p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p>
<p>下载到   themes  文件夹下   </p>
<p>git clone  你选择的主题地址</p>
<p>修改hexo根目录下的  _config.yml   ： theme ： 主题名称</p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/02/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>我的第一篇博客</p>
]]></content>
  </entry>
</search>
